[{"title":"LCA 与 RMQ 问题","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/LCA与RMQ问题/","text":"LCA and RMQ问题描述LCA问题，即最近公共祖先问题。(Lowest common ancestor) 指在一个树或者有向无环图中同时拥有v和w作为后代的最深的节点。在这里，定义一个节点也是其自己的后代，因此如果v是w的后代，那么w就是v和w的最近公共祖先。 RMQ问题，即范围最值查询问题。(Range Minimum Query) 针对数据集的一种条件查询。若给定一个数组$A[1, n]$范围最值查询指定一个范围条件$i$到$j$，要求取出$A[i, j]$中最大/小的元素。 特别的，如果$A$上，任意两个相邻元素相差为$\\pm1$，则称此$RMQ$问题为$\\pm1RMQ$问题。 算法介绍问题建模对于一棵树而言，通过暴力的$DFS$计算总是可以求出一个可行的解出来。但是复杂度比较高，对于频繁的祖先查询很吃力。 这里介绍一种离线的查询方法，即在获得所有的询问情况以后，再进行查询的操作， 求解方法解题报告Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"后缀数组","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/后缀数组/","text":"#Suffix Array 问题描述算法介绍问题建模求解方法解题报告Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"线段树","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/线段树/","text":"Segment tree问题描述算法介绍问题建模求解方法解题报告Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧Poj 1470 Closest Common Ancestors问题描述算法设计程序代码性能分析编程技术技巧","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"树状数组","date":"2018-01-26T10:02:55.881Z","path":"2018/01/26/树状数组/","text":"Binary Indexed Tree问题描述首先来引入一个问题： 给定$n$个数字，有两种频繁的操作需要处理： 求$\\sum_{k = i}^j A_k$； 对某个$A_i$数据进行增减操作。 如果我们使用普通的数组，这两种操作的复杂度分别为$O(n)$和$O(1)$，如果进行$m$次操作，最坏的情况下，复杂度是$O(mn)$的。 所以，为了降低复杂度，我们可以使用一种数组数组的结构，可以将复杂度降低到$O(m\\lg n)$。当然，可以使用$RMQ$的方法，但是$RMQ$的编程实现稍微麻烦些，所以这里介绍数组数组的方法。 算法介绍问题建模因为每个整数都能表示为一些2的幂次方的和，类似于海明码的思路，我们可以使用一个数组，每个数组保存一段数字的求和结果。即为数组里面的元素$BIT_i$对于某一段数据“负责”。 那么如何指定划分的方法，使得每个数组元素各司其职，不会导致浪费呢？我们可以通过对应下标转换为二进制以后的数字来进行确定。这里我们根据每个元素最右边的$1$的位置$r$进行判断。指定索引$i$的负责区域是从$i - 2^r + 1$到$i$。如图所示： 那么如何确定最右边$1$的位置？我们借助计算机基础的知识可知：$r = x \\&amp; (-x)$。 值得一提的是，树状数组中，我们使得下标从$1$开始，这样可以极大的方便我们编程处理。 那么此时获取从数据开头到结尾的求和就很简单，只要给定了数组的下标，我们就可以了解到是哪些$BIT$里面的数据在储存这些求和，将其相加就好。 同样的修改也是类似的思路，我们只需要知道如果知道了需要修改位置的下标，就可以确定需要修改哪些“负责人”的值。 求解方法对于求$r$，在C++里可以将其定义为内联函数，方便求解： 123inline int lowbit(int x) &#123; return x &amp; (-x);&#125; 如果需要求解从开始到位置$i$这一段的和，通过迭代的方式，可以很方便的找到负责任的节点，进行累加操作： 12345678int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125; 如果需要更新某一个位置的数据，可以做一个求和的逆运算，从低往上的修改负责位置： 123456void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125; 在题目的求解过程中，我们经常使用一个求区间$[i, j]$的和的操作，很容易想到，可以通过求$sum(i)$和$sum(j)$以后，直接相减获得。 但是注意到，这里其实是出现了很多的浪费，主要表现为区间$[1, min(i, j)]$中，有相当一部分数据辛辛苦苦求出来以后，又再次相减掉了。其中最坏的情况是只求一个数字，如求$A_i$，这样有$2\\times (\\ulcorner\\log_2i\\urcorner + 1)$次求解都被浪费，对于这种情况，是有对应的方法的。但是会增加些代码复杂性，而且在$O()$标记中是系数项，没有本质影响，在此我们可以先忽视它。 解题报告Poj 3321 Apple Tree问题描述There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree. The tree has N forks which are connected by branches. Kaka numbers the forks by 1 to N and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree. The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka? Input The first line contains an integer N (N ≤ 100,000) , which is the number of the forks in the tree.The following N - 1 lines each contain two integers u and v, which means fork u and fork v are connected by a branch.The next line contains an integer M (M ≤ 100,000).The following M lines each contain a message which is either“C x“ which means the existence of the apple on fork x has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.or“Q x“ which means an inquiry for the number of apples in the sub-tree above the fork x, including the apple (if exists) on the fork xNote the tree is full of apples at the beginning Output For every inquiry, output the correspond answer per line. 算法设计题目中需要求解的是一个子树上所有苹果的个数，如果我们直接开辟空间维护每个子树，那么不论是空间还是时间都是不可以接受的。考虑到树状数组能够求和的性质，我们记录每个点到根节点的上共有多少的苹果。 但是仅仅维护这个数据是不够的，因为我们并不知道从一个树杈上长出来的苹果总和。所以，需要使用$DFS$对于每个节点进行一个编号，同时，对于每一个分叉节点，记录自己从最小孩子到最大孩子的编号，方便查找。这样我们通过查询一个树杈最大最小儿子分别到根节点的苹果数，将这两者相减就是自己所有孩子的苹果总数。最后再加上自己的苹果，就是需要查询的内容。 注意到，题目只保证了根节点编号为$1$，所以需要自己维护一个映射关系，方便从题目给定的节点映射到按照$DFS$顺序访问的节点。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 100000 + 10;int BIT[MAXN];struct Edge &#123; int to; int next;&#125;;struct Map &#123; int begin; int end;&#125;;Edge edge[MAXN * 2];int head[MAXN];Map idMap[MAXN];int apple[MAXN];int cnt;int id;inline void addEdge(int u, int v) &#123; edge[++cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt;&#125;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;void DFS(int u, int father) &#123; idMap[u].begin = ++id; for (int i = head[u]; i != 0; i = edge[i].next) &#123; if (edge[i].to == father) continue; DFS(edge[i].to, u); &#125; idMap[u].end = id;&#125;int n, i, u, v, m;char c;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;n); for (i = 0; i &lt; n - 1; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; DFS(1, -1); for (i = 1; i &lt;= n; ++i) &#123; apple[i] = 1; &#125; for (i = 1; i &lt;= n; ++i) &#123; edit(idMap[i].begin, 1); &#125; scanf(\"%d\", &amp;m); while (m--) &#123; getchar(); scanf(\"%c %d\", &amp;c, &amp;u); if (c == 'C') &#123; if (apple[u]) &#123; apple[u] = 0; edit(idMap[u].begin, -1); &#125; else &#123; apple[u] = 1; edit(idMap[u].begin, 1); &#125; &#125; else &#123; printf(\"%d\\n\", apple[u] + sum(idMap[u].end) - sum(idMap[u].begin)); &#125; &#125;&#125; 性能分析由之前的分析可以知道，每次对于$BIT$的操作复杂度都是$O(\\lg n)$，所以，一共是$m$次输入，总共的复杂度为$O(m\\lg n)$，对于这个树来说，之前$DFS$的$O(n)$的遍历可以不计。 编程技术技巧存粹编程的角度来说，此题并没有使用太多的技巧。 不过第一次接触，很难想到求一个子树和的问题，可以转为一个线性数组的求和。相当于通过$DFS$遍历标号以后，将一个二维的结构，转为一个一维的结构进行求解。通过迂回的求出每个点到根的苹果总数，相减后求子树苹果总和的方法十分巧妙。 Poj 1990 MooFest问题描述Every year, Farmer John’s N (1 &lt;= N &lt;= 20,000) cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. Each cow i has an associated “hearing” threshold v(i) (in the range 1..20,000). If a cow moos to cow i, she must use a volume of at least v(i) times the distance between the two cows in order to be heard by cow i. If two cows i and j wish to converse, they must speak at a volume level equal to the distance between them times max(v(i),v(j)). Suppose each of the N cows is standing in a straight line (each cow at some unique x coordinate in the range 1..20,000), and every pair of cows is carrying on a conversation using the smallest possible volume. Compute the sum of all the volumes produced by all N(N-1)/2 pairs of mooing cows. Input Line 1: A single integer, N Lines 2..N+1: Two integers: the volume threshold and x coordinate for a cow. Line 2 represents the first cow; line 3 represents the second cow; and so on. No two cows will stand at the same location. Output Line 1: A single line with a single integer that is the sum of all the volumes of the conversing cows. 算法设计程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 20000 + 5;struct Cow &#123; int v; int x;&#125;;bool cmp(const Cow &amp;lhs, const Cow &amp;rhs) &#123; return lhs.v &lt; rhs.v;&#125;Cow cow[MAXN];ull BITCount[MAXN];ull BITDistance[MAXN];int n;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline ull sum(int x, ull *BIT) &#123; ull res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, ull *BIT, ull delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d\", &amp;cow[i].v, &amp;cow[i].x); &#125; sort(cow, cow + n, cmp); ull res = 0; ull totalDistance = 0; for (int i = 0; i &lt; n; ++i) &#123; ull leftCount = sum(cow[i].x, BITCount); ull leftDistance = sum(cow[i].x, BITDistance); res += (ull)cow[i].v * (leftCount * (ull)cow[i].x - leftDistance); res += (ull)cow[i].v * (totalDistance - leftDistance - ((ull)i - leftCount) * (ull)cow[i].x); totalDistance += (ull)cow[i].x; edit(cow[i].x, BITCount, 1); edit(cow[i].x, BITDistance, (ull)cow[i].x); &#125; printf(\"%llu\\n\", res);&#125; 性能分析编程技术技巧Poj 2892 Tunnel Warfare问题描述During the War of Resistance Against Japan, tunnel warfare was carried out extensively in the vast areas of north China Plain. Generally speaking, villages connected by tunnels lay in a line. Except the two at the ends, every village was directly connected with two neighboring ones. Frequently the invaders launched attack on some of the villages and destroyed the parts of tunnels in them. The Eighth Route Army commanders requested the latest connection state of the tunnels and villages. If some villages are severely isolated, restoration of connection must be done immediately! Input The first line of the input contains two positive integers n and m (n, m ≤ 50,000) indicating the number of villages and events. Each of the next m lines describes an event. There are three different events described in different format shown below: D x: The x-th village was destroyed.Q x: The Army commands requested the number of villages that x-th village was directly or indirectly connected with including itself.R: The village destroyed last was rebuilt. Output Output the answer to each of the Army commanders’ request in order on a separate line. 算法设计程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 50000 + 5;int BIT[MAXN];int stack[MAXN];int tmp[MAXN];int sp;int n, m, x;char input;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt;= n) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;int countLeft(int x) &#123; int left = 0, right = x; int mid; int pos = 0; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (sum(x) - sum(mid) == 0) &#123; pos = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return pos;&#125;int countRight(int x) &#123; int left = x - 1, right = n; int mid; int pos = 0; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (sum(mid) - sum(x - 1) &gt; 0) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; pos = mid; &#125; &#125; return pos;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;m); while (m--) &#123; getchar(); scanf(\"%c\", &amp;input); if (input != 'R') scanf(\"%d\", &amp;x); switch (input) &#123; case 'D': tmp[x] = 1; stack[sp++] = x; edit(x, 1); break; case 'Q': if (tmp[x] == 1) &#123; printf(\"0\\n\"); continue; &#125; else &#123; printf(\"%d\\n\", countRight(x) - countLeft(x)); &#125; break; default: int pos = stack[--sp]; tmp[pos] = 0; edit(pos, -1); break; &#125; &#125;&#125; 性能分析编程技术技巧Poj 2481 Cows问题描述Farmer John’s cows have discovered that the clover growing along the ridge of the hill (which we can think of as a one-dimensional number line) in his field is particularly good. Farmer John has N cows (we number the cows from 1 to N). Each of Farmer John’s N cows has a range of clover that she particularly likes (these ranges might overlap). The ranges are defined by a closed interval [S,E]. But some cows are strong and some are weak. Given two cows: cowi and cowj, their favourite clover range is [Si, Ei] and [Sj, Ej]. If Si &lt;= Sj and Ej &lt;= Ei and Ei - Si &gt; Ej - Sj, we say that cowiis stronger than cowj. For each cow, how many cows are stronger than her? Farmer John needs your help! Input The input contains multiple test cases.For each test case, the first line is an integer N (1 &lt;= N &lt;= 10^5), which is the number of cows. Then come N lines, the i-th of which contains two integers: S and E(0 &lt;= S &lt; E &lt;= 10^5) specifying the start end location respectively of a range preferred by some cow. Locations are given as distance from the start of the ridge. The end of the input contains a single 0. Output For each test case, output one line containing n space-separated integers, the i-th of which specifying the number of cows that are stronger than cowi. 算法设计程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int BIT[MAXN];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;struct CowRange &#123; int x; int y; int index; int res; CowRange(): x(0), y(0), index(0), res(0) &#123;&#125; CowRange(int x, int y, int index): x(x), y(y), index(index), res(0) &#123;&#125;&#125;;bool preHandle(const CowRange&amp; lhs, const CowRange&amp; rhs) &#123; return lhs.x &lt; rhs.x || ((lhs.x == rhs.x) &amp;&amp; (lhs.y &gt; rhs.y));&#125;bool finishHandle(const CowRange&amp; lhs, const CowRange&amp; rhs) &#123; return lhs.index &lt; rhs.index;&#125;CowRange cows[MAXN];int n;int cnt;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; int x, y; memset(BIT, 0, sizeof(BIT)); cnt = 0; while (cnt &lt; n) &#123; scanf(\"%d %d\", &amp;x, &amp;y); CowRange &amp;r = cows[cnt++]; r.x = x; r.y = y; r.index = cnt; &#125; int pointCnt = 0, saveCnt = 0; sort(cows, cows + cnt, preHandle); for (int i = 0; i &lt; cnt; ++i) &#123; if (i != 0 &amp;&amp; cows[i].y == cows[i - 1].y &amp;&amp; cows[i].x == cows[i - 1].x)&#123; cows[i].res = saveCnt; &#125; else &#123; int aeCnt = pointCnt - sum(cows[i].y + 1); cows[i].res = aeCnt; saveCnt = aeCnt; &#125; ++pointCnt; edit(cows[i].y + 2, 1); &#125; sort(cows, cows + cnt, finishHandle); for (int i = 0; i &lt; cnt - 1; ++i) &#123; printf(\"%d \", cows[i].res); &#125; printf(\"%d\\n\", cows[cnt - 1].res); &#125;&#125; 性能分析编程技术技巧","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"并查集","date":"2018-01-26T06:47:03.191Z","path":"2018/01/26/并查集/","text":"UnionFind问题描述在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： $Find$：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 $Union$：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，$Find(x)$返回 x 所属集合的代表，而$Union$使用两个集合的代表作为参数。 更进一步的，当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系。 带权并查集即是结点存有权值信息的并查集。 算法介绍问题建模并查集的本质是一个森林，每棵树代表一个集合，树根为集合的代表元。 我们可以使用有根树来进行建模，对于一个新加入的节点，就将其添加到对应的集合里面去。那么如何维护这个集合关系呢？只需要使得每个节点保存自己父亲节点即可。 但是即便如此，效率也还是不高，因为随着规模的增大，树的深度提高，查找的效率下降严重。所以，每次查找的时候，如果路径较长，则修改信息，以便下次查找的时候速度更快。这就是“路径压缩”的思想。 同时，我们也可以维护一个$rank$值，表示一个树的规模，我们总是把小树合并到大树上面，这样可以有效的降低深度，防止最坏情况的发生。 求解方法并查集的代码书写十分简单，首先初始情况下，可以把每个点都看成是一个小的集合，通过将$father$数组指定为自己本身来实现。 在$Find$操作中，如果祖宗节点就是自己本身，则可以直接返回；如果不是自己，需要进行递归的操作，具体来说，在计算权值关系的同时，需要将自己合并到自己的祖宗节点之上，通过这个方式可以有效的降低树的深度。 在$Union$操作中，通过比较$rank$来进行合并的操作，可以有效的减少复杂度。 C++代码如下： 123456789101112131415161718192021222324void init () &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125;&#125;int setFind(int x) &#123; if (father[x] == x) return x; int tmpFather = father[x]; father[x] = setFind(father[x]); relation[x] = caculateRelation; return father[x];&#125;void setUnion(int r, int x, int y, int rx, int ry) &#123; int rx = setFind(x); int ry = setFind(y); if (rank[rx] &gt; rank[ry]) &#123; father[ry] = rx; relation[ry] = caculateRelation; &#125; else &#123; father[rx] = ry; relation[rx] = caculateRelation; &#125;&#125; 值得一提的是，使用并查集操作，其复杂度为$O(\\alpha(n))$，其中$\\alpha()$为阿克曼函数的反函数。 解题报告Poj 1182 食物链问题描述动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output 只有一个整数，表示假话的数目。 算法设计食物链题目是带权并查集的经典题目，首先我们需要明确这里的关系是什么。 根据题目的含义，我们总结出下面三种关系： 关系 代表 和父亲节点同类 0 被自己的父亲节点吃 1 吃自己的父亲节点 2 首先判断数据的规模是否符合题目范围的限制，这个很容易判断。 之后，通过$Find$函数判断这两个点是否在同一个关系集合下面，如果是同一个集合，这里分为两种情况： 是同类 可以直接判断，如果存在“吃”的关系，则说谎数目增加， 否则，将关系纳入并查集中。 存在“吃”或者“被吃”的关系 注意到，这里的食物链其实是一种循环的关系，如图所示： 所以，可以通过取模的关系，进行判断，具体为：$(R_x + d) \\% 3\\ ==\\ R_y$。 如果两者之间没有关系，则需要对关系进行合并，注意合并的时候，一定要分清需要将谁合并到谁，因为这里除了信息给出的新关系，还需要考虑两个节点和各自的祖宗之间的关系，比较复杂。这里给出一个例子：$((3 - R_x) + R_y + d - 1) \\ \\% \\ 3$。 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Relation &#123; int father; int relation; Relation(): father(0), relation(0) &#123;&#125;&#125;;const int MAXN = 50000 + 5;Relation unionFind[MAXN];int n, k;int setfind(int x) &#123; if (unionFind[x].father == x) return x; int tmpFather = unionFind[x].father; unionFind[x].father = setfind(unionFind[x].father); unionFind[x].relation = (unionFind[tmpFather].relation + unionFind[x].relation) % 3; return unionFind[x].father;&#125;void unionSet(int d, int x, int y, int fx, int fy) &#123; unionFind[fx].father = fy; unionFind[fx].relation = ((3 - unionFind[x].relation) + unionFind[y].relation + d - 1) % 3;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; unionFind[i].father = i; &#125; int res = 0; int d, x, y; while (k--) &#123; scanf(\"%d %d %d\", &amp;d, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; ++res; continue; &#125; if (d == 2 &amp;&amp; x == y) &#123; ++res; continue; &#125; int fx = setfind(x); int fy = setfind(y); if (fx == fy) &#123; if (d == 1 &amp;&amp; unionFind[x].relation != unionFind[y].relation) &#123; ++res; continue; &#125; else if (d == 2 &amp;&amp; (unionFind[y].relation + 1) % 3 != unionFind[x].relation) &#123; ++res; continue; &#125; &#125; else &#123; unionSet(d, x, y, fx, fy); &#125; &#125; printf(\"%d\\n\", res);&#125; 性能分析由于并查集操作十分的快捷，可以认为其中的每次添加或者查询的时间复杂度是$O(\\alpha(n))$级别的，所以最后总的时间复杂度是$O(n\\alpha(n))$。 编程技术技巧此时是并查集的模版题，其中的大部分代码可以直接复用。 不过，虽然并查集本身的操作复杂度很低，我们仍然可以对$Union$操作进行些许的优化。因为这里就题目而言，我们一定会在$Union$操作之前进行两次的$Find$操作，所以这里可以直接将上一步中得到的$x$和$y$的祖先节点，传入$Union$函数中，就不用在$Union$函数中反复的调用了。 Poj 1733 Parity game问题描述Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on. Your task is to guess the entire sequence of numbers. You suspect some of your friend’s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer. Input The first line of input contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either ‘’even’’ or ‘’odd’’ (the answer, i.e. the parity of the number of ones in the chosen subsequence, where ‘’even’’ means an even number of ones and ‘’odd’’ means an odd number). Output There is only one line in output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked. 算法设计这道题目虽然是使用并查集完成，但是内部的关系不是很容易理清。因为输入的区间是包括了端点，所以很容易出现了区间重合的情况不好区分，于是可以将左端点减一以后，看作是一个左开右闭区间，这样书写起来关系就可以比较清晰。 稍有计算机常识的都可以知道，对于一段数据的奇偶性进行运算可以使用异或 (^)的方法。我们可以通过此运算，对于中间关系进行求解。 但是，这道题还有一点很重要的技巧，因为输入的区间过于庞大，所以如果直接使用给定的范围开辟空间，十分容易卡空间。所以需要进行一个$hash$化的处理。$hash$的方法很多，比较简单的是使用C++的$STL$里面的$map$，进行处理。因为$map$内部使用了红黑树，有良好的平衡性，所以开销不是很高，编程极容易实现。 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;struct Relation &#123; int father; int relation; Relation(): father(0), relation(0) &#123;&#125;&#125;;const int MAXN = 10000 + 3;const int MAXSIZE = 5000 + 3;Relation set[MAXN];unsigned x_array[MAXSIZE];unsigned y_array[MAXSIZE];int r_array[MAXSIZE];int p = 0;map&lt;unsigned, int&gt; hashMap;int setFind(int x) &#123; if (set[x].father == x) return x; int tmpFather = set[x].father; set[x].father = setFind(set[x].father); set[x].relation = set[x].relation ^ set[tmpFather].relation; return set[x].father;&#125;void setUnion (int r, int x, int y, int rx, int ry) &#123; if (rx &lt; ry) &#123; set[ry].father = rx; set[ry].relation = r ^ set[x].relation ^ set[y].relation; &#125; else &#123; set[rx].father = ry; set[rx].relation = r ^ set[x].relation ^ set[y].relation; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif int n, size; scanf(\"%d\", &amp;n); scanf(\"%d\", &amp;size); unsigned t_x, t_y; int x, y, r; char str[5]; for (int i = 0; i &lt; MAXN; ++i) &#123; set[i].father = i; &#125; int res = 0; for (int i = 0; i &lt; size; ++i) &#123; scanf(\"%u %u %s\", &amp;t_x, &amp;t_y, str); hashMap[t_x] = 0; hashMap[t_y] = 0; if (str[0] == 'e') r_array[i] = 0; else r_array[i] = 1; x_array[i] = t_x; y_array[i] = t_y; &#125; for (map&lt;unsigned, int&gt;::iterator i = hashMap.begin(); i != hashMap.end(); ++i) &#123; i-&gt;second = ++p; &#125; for (int i = 0; i &lt; size; ++i) &#123; x = hashMap[x_array[i]]; y = hashMap[y_array[i]]; r = r_array[i]; --x; int rx = setFind(x); int ry = setFind(y); if (rx != ry) &#123; setUnion(r, x, y, rx, ry); ++res; &#125; else &#123; if (set[x].relation ^ set[y].relation ^ r) break; ++res; &#125; &#125; printf(\"%d\\n\", res);&#125; 性能分析对于每一步的关系处理来说，都是$O(1)$的操作，所以仍然为最后的$O(\\alpha(n))$级别。不过在$hash$的过程中，每一步是$O(\\lg n)$的级别。所以最后的时间复杂度是由$hash$主导，为$O(n\\lg n)$。在Poj平台上为235MS。 编程技术技巧这道题目主要有三个特别注意的地方： 使用左开右闭区间代替原来的题目描述，方便编程和自己的理解。 使用异或操作降低复杂度，如果采用和第一题一样的取模的方法，从计算机系统的角度考虑耗时要高。 使用$STL$里的$map$来进行$hash$化的操作，开销较小，并且编程容易实现。 Poj 2912 Rochambeau问题描述N children are playing Rochambeau (scissors-rock-cloth) game with you. One of them is the judge. The rest children are divided into three groups (it is possible that some group is empty). You don’t know who is the judge, or how the children are grouped. Then the children start playing Rochambeau game for M rounds. Each round two children are arbitrarily selected to play Rochambeau for one once, and you will be told the outcome while not knowing which gesture the children presented. It is known that the children in the same group would present the same gesture (hence, two children in the same group always get draw when playing) and different groups for different gestures. The judge would present gesture randomly each time, hence no one knows what gesture the judge would present. Can you guess who is the judge after after the game ends? If you can, after how many rounds can you find out the judge at the earliest? Input Input contains multiple test cases. Each test case starts with two integers N and M (1 ≤ N ≤ 500, 0 ≤ M ≤ 2,000) in one line, which are the number of children and the number of rounds. Following are M lines, each line contains two integers in [0, N) separated by one symbol. The two integers are the IDs of the two children selected to play Rochambeau for this round. The symbol may be “=”, “&gt;” or “&lt;”, referring to a draw, that first child wins and that second child wins respectively. Output There is only one line for each test case. If the judge can be found, print the ID of the judge, and the least number of rounds after which the judge can be uniquely determined. If the judge can not be found, or the outcomes of the M rounds of game are inconsistent, print the corresponding message. 算法设计本题的思路和食物链基本一致，甚至解题主体都是差不多的。唯一的区别是引入了一个裁判，这个裁判不属于任何的集合，每次都可以说不同的话。所以为了找出谁是裁判，需要对于每个人进行一次假设，判断如果他是裁判，能不能没有冲突。所以这里需要循环$n$次。如果没有一个是满足的，则输出”Impossible”，如果有很多裁判都可以导致没有冲突，则输出”Can not determine”。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int MAXM = 2000 + 5;const int MAXN = 500 + 5;int father[MAXN];int relation[MAXN];int x_array[MAXM];int y_array[MAXM];int r_array[MAXM];int n, m;int x, y, r;int setFind(int x) &#123; if (father[x] == x) return x; int tmpFather = father[x]; father[x] = setFind(father[x]); relation[x] = (relation[x] + relation[tmpFather]) % 3; return father[x];&#125;void setUnion(int r, int x, int y, int rx, int ry) &#123; // int rx = setFind(x); // int ry = setFind(y); father[ry] = rx; relation[ry] = (relation[x] + (3 - relation[y]) + r) % 3;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d\", &amp;n, &amp;m) == 2) &#123; memset(x_array, 0, sizeof(x_array)); memset(y_array, 0, sizeof(y_array)); memset(r_array, 0, sizeof(r_array)); char rTmp; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d%c%d\", x_array + i, &amp;rTmp, y_array + i); if (rTmp == '&lt;') r_array[i] = 1; else if (rTmp == '&gt;') &#123; r_array[i] = 2; &#125; else r_array[i] = 0; &#125; int judgeCnt = 0; int judge = 0; int line = -1; for (int current = 0; current &lt; n; ++current) &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125; memset(relation, 0, sizeof(relation)); bool flag = true; for (int i = 0; i &lt; m; ++i) &#123; x = x_array[i]; y = y_array[i]; r = r_array[i]; if (x == current || y == current) continue; int rx = setFind(x); int ry = setFind(y); if (rx == ry) &#123; if ((relation[y] + (3 - relation[x])) % 3 != r) &#123; // cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; line = max(line, i); flag = false; break; &#125; &#125; else &#123; setUnion(r, x, y, rx, ry); &#125; &#125; if (flag) &#123; judge = current; ++judgeCnt; &#125; &#125; if (!judgeCnt) &#123; printf(\"Impossible\\n\"); &#125; else if (judgeCnt == 1) &#123; printf(\"Player %d can be determined to be the judge after %d lines\\n\", judge, line + 1); &#125; else &#123; printf(\"Can not determine\\n\"); &#125; &#125;&#125; 性能分析因为内部需要对裁判的可能性进行判断，所以进行$n$次的遍历。总的复杂度为$O(n^2\\alpha(n))$。 编程技术技巧思路和食物链基本一致，可以参考前面的编程技巧。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"差分约束系统","date":"2018-01-24T09:51:03.626Z","path":"2018/01/24/差分约束系统/","text":"System of Difference Constraints问题描述首先先引入一个通用的线性规划问题，给定一个$m \\times n$的矩阵A，一个$m$维的向量$b$和一个$n$维向量$c$。希望能够找到一个$n$维的向量$x$，使得在由$Ax \\leqslant b$给定的$m$个约束条件下优化目标函数$\\sum_{i = 1}^n c_ix_i$，使得目标函数的取值最大。有时，我们并不关心目标函数，而是仅仅希望能找到一个可行解，即找到任何满足$Ax \\leqslant b$的向量$x$，或者判断不存在可行解。 观察一个特例情况，如果线性规划的矩阵$A$的每一行包括一个1和一个-1，其他的所有项皆为0。则对于$Ax \\leqslant b$所给出的约束条件变为$m$个涉及$n$个变量的差额限制条件，此时每个约束条件退化为简单的线性不等式：$x_j - x_i \\leqslant b_k$。这里$1 \\leqslant i, j \\leqslant n$，$i \\neq j$，且$1 \\leqslant k \\leqslant m$。 算法介绍问题建模对于此类问题，可以从图论的角度进行理解。 在一个$Ax \\leqslant b$的差分约束系统中，我们将$m \\times n$的线性规划矩阵$A$看作是一张由$n$个节点和$m$条边构成的图的邻接矩阵的转置。这里定义下约束图的概念： 约束图是一个带有权重的有向图$G = (V, E)$，这里 $V = {v_0, v_1, …, v_n }$，$E = {(v_i, v_j): x_j - x_i \\leqslant b_k } \\bigcup {(v_0, v_1), (v_0, v_2, …, (v_0, v_n)}$。 这里的$v_0$可以看作是一个额外的节点，用来保证图中至少有一个节点，并且从其出发可以到达所有的其他的节点。其中，如果$x_j - x_i \\leqslant b_k$是一个差分约束条件，则边$(v_i, v_j)$的权重为$w(v_i, v_j) = b_k$。 举例说明： 对于一组差分约束条件：$$\\begin{cases}x_1 - x_2 \\leqslant 0\\x_1 - x_5 \\leqslant -1\\x_2 - x_5 \\leqslant 1\\x_3 - x_1 \\leqslant 5\\x_4 - x_1 \\leqslant 4\\x_4 - x_3 \\leqslant -1\\x_5 - x_3 \\leqslant -3\\x_5 - x_4 \\leqslant -3\\\\end{cases}$$可以描绘出如下的差分约束系统的约束图： 其中，$(-5, -3, 0, -1, -4)$为满足条件的一个解。 不难发现，使用最短路算法中的松弛操作：$d(v) - d(u) \\leqslant w(u, v)$，刚好可以转为一个差分约束的条件：$i - j \\leqslant u$。于是，对于差分约束的问题，可以将未知数$x_i$对应一个顶点，将不等式$x_i - x_j \\leqslant c$转化为一条从$x_j$到$x_i$权值为$c$的边。 下面考虑两种特殊情况： 无解。当图中出现了负权环的时候，此时的最短路可以无限小，表现为$x_i - x_j \\leqslant c$中的$c$可以无限的小，所以满足条件的最大值不存在。 有无穷多解。当图中出现了不连通的情况，即起点$s$到终点$t$不可达，此时表示没有约束条件，即有无穷多的解。 求解方法对于一个最短路问题，经常使用$Dijkstra$算法或$Bellman-Ford$算法进行求解。如果转化的图中没有负权值的边，可以使用复杂度更低的$Dijkstra$算法进行计算。如果存在负权值的情况，当然可以通过$Bellman-Ford$算法进行判断，但是此算法的复杂度是$O(mn)$，我们这里使用改进版的$SPFA$算法进行求解。 123456789101112131415161718192021bool spfa(s) for i from 0 to n - 1 d[i] = (i == s) ? 0 : INF; inq[i] = (i == s); // 入队列标记 visitCount[i] = 0; // 对负权环进行判断 q.push( (d[s], s) ); while( !q.empty() ) (dist, u) = q.pop(); // 取首元素 inq[u] = false; if( visitCount[u]++ &gt; n ) // 存在负权环 return true; for u 出发的所有的边 e v = edge[e].v; w = edge[e].w; if(d[u] + w &lt; d[v]) d[v] = d[u] + w; // 松弛操作 if ( !inq[v] ) inq[v] = true; q.push( (d[v], v) ); return false; 解题报告Poj 3159 Candies问题描述During the kindergarten days, flymouse was the monitor of his class. Occasionally the head-teacher brought the kids of flymouse’s class a large bag of candies and had flymouse distribute them. All the kids loved candies very much and often compared the numbers of candies they got with others. A kid A could had the idea that though it might be the case that another kid B was better than him in some aspect and therefore had a reason for deserving more candies than he did, he should never get a certain number of candies fewer than B did no matter how many candies he actually got, otherwise he would feel dissatisfied and go to the head-teacher to complain about flymouse’s biased distribution. snoopy shared class with flymouse at that time. flymouse always compared the number of his candies with that of snoopy’s. He wanted to make the difference between the numbers as large as possible while keeping every kid satisfied. Now he had just got another bag of candies from the head-teacher, what was the largest difference he could make out of it? Input The input contains a single test cases. The test cases starts with a line with two integers N and M not exceeding 30 000 and 150 000 respectively. N is the number of kids in the class and the kids were numbered 1 through N. snoopy and flymouse were always numbered 1 and N. Then follow M lines each holding three integers A, B and c in order, meaning that kid A believed that kid Bshould never get over c candies more than he did. Ouput Output one line with only the largest difference desired. The difference is guaranteed to be finite. 算法设计可以看出，每一个孩子在心里对于“公平”都有不同的界定，可以用一个不等式来描述他们每个人能够容忍的最大的差异性对待。 比如$1\\ 2\\ 5$表述了孩子$1$能够容忍孩子$2$比自己多$5$块糖果。那么可以表达为：$x_2 - x_1 \\leqslant 5$，对应到图上是一个从点$x_1$到点$x_2$的一个权值为$5$的边。 分析可知，这里的所有权值都为正数，可以直接使用$Dijkstra$进行编写。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 30000 + 10;const int MAXM = 150000 + 10;const int INF = 0x3f3f3f3f;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;struct Pair &#123; int v; int w; Pair(int _v, int _w): v(_v), w(_w) &#123;&#125;&#125;;struct Cmp &#123; bool operator() (const Pair&amp; lhs, const Pair&amp; rhs) &#123; return lhs.w &gt; rhs.w; &#125;&#125;;int n, m;int u, v, w;int d[MAXN];bool visited[MAXN];void dijkstra(int s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; visited[i] = false; &#125; priority_queue&lt;Pair, vector&lt;Pair&gt;, Cmp&gt;q; q.push(Pair(s, 0)); visited[s] = true; d[s] = 0; while (!q.empty()) &#123; Pair current = q.top(); if (current.v == n) return; q.pop(); visited[current.v] = true; for (int i = head[current.v]; i != 0; i = edge[i].next) &#123; if (visited[edge[i].to]) continue; if (d[current.v] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current.v] + edge[i].w; q.push(Pair(edge[i].to, d[edge[i].to])); &#125; &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; dijkstra(1); printf(\"%d\\n\", d[n]);&#125; 性能分析此处使用了优先队列优化的$Dijkstra$算法，算法的复杂度为$O(E\\lg V)$，空间上使用了链式向前星，减少了建图$malloc$的开销，最后Poj上的开销为：空间 2432K，时间672MS。 编程技术技巧 在建图的过程中，如果使用临接矩阵的结构，则空间开销为$O(n^2)$。如果使用临接表结构，此时很难估计规模，需要产生$malloc$的开销。这里使用了链式向前星，预先根据输入的规模开辟数组，通过链表的形式，将边储存下来，进行同时保证了访问的快捷性。 $Dijkstra$算法可以通过判断是否已经在$V$集合中进行剪枝的操作，避免不必要的运算。经对比发现，速度增加了$100\\%$。 Poj 1275 Cashier Employment问题描述A supermarket in Tehran is open 24 hours a day every day and needs a number of cashiers to fit its need. The supermarket manager has hired you to help him, solve his problem. The problem is that the supermarket needs different number of cashiers at different times of each day (for example, a few cashiers after midnight, and many in the afternoon) to provide good service to its customers, and he wants to hire the least number of cashiers for this job. The manager has provided you with the least number of cashiers needed for every one-hour slot of the day. This data is given as R(0), R(1), …, R(23): R(0) represents the least number of cashiers needed from midnight to 1:00 A.M., R(1) shows this number for duration of 1:00 A.M. to 2:00 A.M., and so on. Note that these numbers are the same every day. There are N qualified applicants for this job. Each applicant i works non-stop once each 24 hours in a shift of exactly 8 hours starting from a specified hour, say ti (0 &lt;= ti &lt;= 23), exactly from the start of the hour mentioned. That is, if the ith applicant is hired, he/she will work starting from ti o’clock sharp for 8 hours. Cashiers do not replace one another and work exactly as scheduled, and there are enough cash registers and counters for those who are hired. You are to write a program to read the R(i) ‘s for i=0..23 and ti ‘s for i=1..N that are all, non-negative integer numbers and compute the least number of cashiers needed to be employed to meet the mentioned constraints. Note that there can be more cashiers than the least number needed for a specific slot. Input The first line of input is the number of test cases for this problem (at most 20). Each test case starts with 24 integer numbers representing the R(0), R(1), …, R(23) in one line (R(i) can be at most 1000). Then there is N, number of applicants in another line (0 &lt;= N &lt;= 1000), after which come N lines each containing one ti (0 &lt;= ti &lt;= 23). There are no blank lines between test cases. Output For each test case, the output should be written in one line, which is the least number of cashiers needed.If there is no solution for the test case, you should write No Solution for that case. 算法设计此题转化为图的分析过程比较复杂，首先已知量是$R_0, R1,\\dots, R{23}$表示从$0$开始到$23$点结束每个小时需要的员工数量，同时$B_0, B1, \\dots, B{23}$是从这一刻能够开始工作的人的数量，这个数据可以从应聘者这里获得。现在需要解决的问题是，如何求出每个时刻需要开始工作的人数。 如果我们使用$A_0, A1, \\dots, A{23}$表示在对应的时刻能够开始工作的人数，因为每个人一天可以工作$8$个小时，所以要考虑到工人跨天的情况，对于$i \\geqslant 7$的情况：$$A{i-7} + A{i -6} + A_{i - 5} + \\dots + A_i \\geqslant R_i$$对于$0 \\leqslant i &lt; 7$的情况：$$(A_0 + \\dots + Ai)+ (A{i + 17} + \\dots + A_{23}) \\geqslant R_i$$但是，仅仅这个约束条件是不够的，对于$i \\in [0, 24)$，我们还有：$$0 \\leqslant A_i \\leqslant B_i$$为了方便起见，可以使用$Si = \\sum{j = 0}^{i}A_j$来表示一段的和。 则上面的式子可以转化为：$$\\begin{cases}Si - S{i - 8} \\geqslant R_i &amp; i \\geqslant 7\\Si + S{23} - S_{i + 16} \\geqslant R_i &amp; 0 \\leqslant i &lt; 7\\0 \\leqslant Si - S{i - 1} \\leqslant Bi &amp; 0 \\leqslant i &lt; 24\\\\end{cases}$$就可以直接将这个式子转化为图进行计算，但是这里注意到，$S{23}$是一个未知量，所以这里需要进行枚举$S_{23}$的可能取值，选择一个能够满足条件最小的进行输出。 注意这里有点技巧，$S_{23}$虽然值不大，但是也是$O(n)$级别，和求职者的个数相关，所以可以采用二分查找的方法，将复杂度降低到$O(\\lg n)$。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000 + 10;const int MAXM = 2000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN; &#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;bool inQueue[MAXN];int d[MAXN];int visitedCnt[MAXN];int qTime;int m;int u, v, w;bool spfa(int s) &#123; for (int i = 1; i &lt;= 24; ++i) &#123; d[i] = INF; inQueue[i] = false; &#125; d[s] = 0; visitedCnt[s] = 1; inQueue[s] = true; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; if (visitedCnt[edge[i].to]++ &gt; 24) return false; inQueue[edge[i].to] = true; push(edge[i].to); &#125; &#125; &#125; &#125; return true;&#125;int R[25];int b[25];int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;qTime); while (qTime--) &#123; memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= 24; ++i) &#123; scanf(\"%d\", R + i); &#125; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;u); ++b[u + 1]; &#125; int res = 0; int l = 1, r = m; int middle; while (l &lt;= r) &#123; middle = (l + r) &gt;&gt; 1; memset(head, 0, sizeof(head)); cnt = h = t = 0; memset(visitedCnt, 0, sizeof(visitedCnt)); for (int i = 8; i &lt;= 24; ++i) &#123; addEdge(i, i - 8, -R[i]); &#125; for (int i = 1; i &lt;= 7; ++i) &#123; addEdge(i, i + 16, -R[i] + middle); &#125; for (int i = 1; i &lt;= 24; ++i) &#123; addEdge(i, i - 1, 0); addEdge(i - 1, i, b[i]); &#125; addEdge(24, 0, -middle); addEdge(0, 24, middle); if (spfa(0)) &#123; res = middle; r = middle - 1; &#125; else &#123; l = middle + 1; &#125; &#125; if (res) printf(\"%d\\n\", res); else printf(\"No Solution\\n\"); &#125;&#125; 性能分析由于$SPFA$的算法复杂度由论文可知为$O(kE)$，建图需要$O(n)$，而对于二分查找需要$O(\\lg n)$次，所以最后的复杂度是$O(n\\lg n)$。最后Poj上开销为空间188K，时间16MS。 编程技术技巧分配收银员这题，第一次使用了$SPFA$算法，在何时对于不可能的情况（即出现了负权的环）进行剪枝是十分重要的，我们可以在将点入队列前，进行检查，这样可以节省一定的开销。 同时正如前面讲过的，如果出现了一个有序的排列，并且我们需要对其进行搜索，那么此时使用二分法进行查找是十分高效的，必须要将二分法熟练的掌握。 Poj 1201 Intervals问题描述You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.Write a program that:reads the number of intervals, their end points and integers c1, …, cn from the standard input,computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,writes the answer to the standard output. Input The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) – the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1. Output The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n. 算法设计题目中给定的条件为每个区间内至少需要选中的点的个数，现在求整个区间需要被选中的点的个数$S$，并且使得$S$最小。 此题的思路可以参考上面的一题，因为最后需要求出一个完整区间的个数，所以直接设$S_i$为$[0, i)$中点的个数。于是，举个例子，如果题目输入$1\\ 3\\ 1$，则可以转化为：$S_3 - S_1 \\geqslant 1$。 当然，值得一提的是，仅仅这些条件是不够的，我们必须要保证每个点最多只能被选中一次。所以有：$1 \\geqslant Si - S{i - 1} \\geqslant 0$。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 60000 + 10;const int MAXM = 240000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN;&#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;bool inQueue[MAXN];int d[MAXN];int n;int u, v, w;int left, right;bool spfa(int s) &#123; for (int i = ::left; i &lt;= ::right; ++i) &#123; d[i] = INF; inQueue[i] = false; &#125; d[s] = 0; inQueue[s] = true; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; inQueue[edge[i].to] = true; push(edge[i].to); &#125; &#125; &#125; &#125; return true;&#125;int main (int argc, char * argv[]) &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d\", &amp;n) == 1) &#123; memset(head, 0, sizeof(head)); cnt = h = t = 0; ::left = MAXN; ::right = 0; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(v + 1, u, -w); ::left = min(::left, u); ::right = max(::right, v + 1); &#125; for (int i = ::left; i &lt;= ::right; ++i) &#123; addEdge(i, i - 1, 0); addEdge(i - 1, i, 1); &#125; spfa(::right); printf(\"%d\\n\", d[::right] - d[::left]); &#125;&#125; 性能分析对于每一次的运算，基本可以看作是$SPFA$的时间开销，即$O(kE)$。在Poj上的运行时间是313MS。 编程技术技巧这里的区间范围是$[1, 5000]$，可以接受，但是如果输入的数字本身的范围比较小的话，我们可以只考虑题目中出现的范围，这样将图缩小很多，提高运行的速度。 具体来说，输入的时候需要记录本样例的最左边和最右边的值，计算时只需要计算这两个值即可。 ###Poj 3169 Layout 问题描述Like everyone else, cows like to stand close to their friends when queuing for feed. FJ has N (2 &lt;= N &lt;= 1,000) cows numbered 1..N standing along a straight line waiting for feed. The cows are standing in the same order as they are numbered, and since they can be rather pushy, it is possible that two or more cows can line up at exactly the same location (that is, if we think of each cow as being located at some coordinate on a number line, then it is possible for two or more cows to share the same coordinate). Some cows like each other and want to be within a certain distance of each other in line. Some really dislike each other and want to be separated by at least a certain distance. A list of ML (1 &lt;= ML &lt;= 10,000) constraints describes which cows like each other and the maximum distance by which they may be separated; a subsequent list of MD constraints (1 &lt;= MD &lt;= 10,000) tells which cows dislike each other and the minimum distance by which they must be separated. Your job is to compute, if possible, the maximum possible distance between cow 1 and cow N that satisfies the distance constraints. Input Line 1: Three space-separated integers: N, ML, and MD. Lines 2..ML+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at most D (1 &lt;= D &lt;= 1,000,000) apart. Lines ML+2..ML+MD+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at least D (1 &lt;= D &lt;= 1,000,000) apart. Output Line 1: A single integer. If no line-up is possible, output -1. If cows 1 and N can be arbitrarily far apart, output -2. Otherwise output the greatest possible distance between cows 1 and N. 算法设计做完前面的$3$题以后，这道题目就比较简单了。 输入有两种，分别是两头牛最多距离多远和两头牛最少相隔多远。这个条件可以很容易的转化为不等式来书写。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;const int MAXM = 20000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN;&#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;int inQueue[MAXN];int d[MAXN];int n;int u, v, w;int ml, md;int visitCnt[MAXN];bool spfa(int s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; &#125; d[s] = 0; inQueue[s] = true; visitCnt[s] = 1; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; inQueue[edge[i].to] = true; push(edge[i].to); if (++visitCnt[edge[i].to] &gt; n) return false; &#125; &#125; &#125; &#125; return true;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d %d\", &amp;n, &amp;ml, &amp;md) == 3) &#123; memset(head, 0, sizeof(head)); memset(visitCnt, 0, sizeof(visitCnt)); cnt = h = t = 0; for (int i = 0; i &lt; ml; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; for (int i = 0; i &lt; md; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(v, u, -w); &#125; if (spfa(1)) &#123; if (d[n] != INF) printf(\"%d\\n\", d[n]); else printf(\"-2\\n\"); &#125; else printf(\"-1\\n\"); &#125;&#125; 性能分析同上题一样，使用$SPFA$算法，复杂度类似。 编程技术技巧本题就是差分约束系统的基础题型，思想和前面的$3$题类似，没有特别的技巧。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"ASPLOS半日行","date":"2017-04-17T13:09:05.000Z","path":"2017/04/17/ASPLOS/","text":"ASPLOS半日行真是出乎意料，自己能以本科生的身份 体验了计算机顶级会议ASPLOS 2017 作为一个还在刷 CSAPP 的小白，十分幸运能够来到西安，和众多世界级的科学家坐在一起，聆听并感受CS最前沿的科技革新。在此，首先要感谢的是为我们争取机会的@石老师，以及同行的15级ACM班全体大佬们。 长安古风 一日看尽长安花 标志的大雁塔，东西两部的钟楼和鼓楼 厚重的西安城墙，依稀看到古都的影子 biangbiang面，羊肉泡馍，特色的西安小吃 粗犷的西北饮食风格，感受长安城独到的魅力 Main Conference开场第一次接触这种顶级的会议，没有想象中的严肃刻板。反而感受到了一种轻松融洽的气氛，周围就坐的人都非常友善亲切。 阿里的首席科学家周靖人开场讲解了阿里云的技术创新，不仅包括大数据和AI，还有各种交互式 流计算和图计算等等。在数据质量检测和机器学习方面，也有所涉及。 虽然关于技术讲解并没有想象中的高深莫测，但也足够窥见阿里背后的惊人的技术投入，我对于阿里的印象也从策划公司转变到了科技公司，感受到了企业对于世界计算机技术发展的强大推动力。 Lighting Session受制于现在的专业知识水平，如果说之前周靖人的演讲能够让我大体听懂，之后90秒一篇的paper对于我的确有些勉强。能够理解表达的中心含义实属不易，但是即便如此，还是能够感受到这些世界顶级的科研人员对于技术的热情。 像下面这位天生的演讲家。 初步接触到了世界最前沿的技术和发展方向，明白了现在计算机领域究竟在研究什么样的问题，以及问题背后的驱动力量。 Solution并不重要，motivation才是重中之重。 Best Paper很庆幸，在会议之前我们集体研究过上午很多paper的主题，基本上能够更随着主讲者的思路向前推进。个人当然对于会议提到Mallacc和RedSpy比较感兴趣，会议后也关注了RedSpy的开源项目。 虽然对于内部的实现方式仅仅一知半解，但是他们所解决的大问题，也都是我在学习过程中曾经有过的一些小想法。所以，灵感就在转瞬间，如何抓住，如何踏踏实实的研究下去，也是我以后要思考和为之奋斗的问题。 Lunch Time实话实说，这次我的注意力完全没有放在午餐上面。除了保持坐姿和吃相以外，所有的精力都放在了如何同周围的学术大牛交流上面。 坐在对面的是一位芝加哥大学的留学博士生，无奈我口语硬伤，使用纯英文沟通还是有很多词不达意的情况，最后干脆中英混杂聊了起来。虽然因为语言问题略显尴尬，但还是了解到了相当多的关于留学深造以及国外科研的情况，他也很坦然的教给了我一些关于国外学校和微软亚洲研究院的申请技巧。 当然我们还聊到了本科生的课程问题，他也说出了他的理解，认为没有必要追求最主流的技术，毕竟搞教学最前沿的不一定是最能够让人理解和接受，不然何不每天讲解两篇paper呢。当然，在午饭最后，我也得到了他的邮箱，希望以后能够继续交流。 当然，唯一遗憾的还是没能和斜对面的Best Paper的得主交流。确实，在如何套磁方面我还是一点不懂，口语也并不过关，失去了一些机会，这也是我之后努力的方向吧。 Summary西安的顶会之行真的收获了很多，虽然真正参会的只有半天，但是我也初次窥得了世界最前沿的技术究竟是什么样子；初次了解了计算机究竟应该去做什么，计算机的本质问题是什么；更重要的是能和一批最顶尖的研究者做在一起，去了解他们的研究方式和思维方式。越厉害的人越是谦虚，当一个真正的大牛能够face to face和你交流知识，这种欣喜可想而知。 ASPLOS之行给我心里种下了一颗种子 我已经迫不及待的看到他的生根 发芽 结果 希望这一天，并不遥远。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]},{"title":"2016 Summary","date":"2017-01-22T14:17:00.000Z","path":"2017/01/22/2016 Summary/","text":"2016 Summary一学期竟然过的这么快，真是难以想象。暮然回首时，仿佛还能看见昔日的我。 致往日的我 “ flag 就是用来被推翻的。” 报名时的我依稀记得大一军训的时候，听到了联创这个团队。 “他是联创dalao”，“卧槽，好牛逼啊”。 显然，就像经典的电影桥段，当我终于计划好要报名的时候，发现早就过了截止日期。 一转眼到了大二，在年级群里再一次听到了联创这个名字，仿佛冥冥的召唤，我不假思索的报了名。 显然，就像经典的电影桥段，这一次没有错过。 测试时的我其实我是很期待熬测的，一开始只是觉得好玩。毕竟之前写过一些iOS的App，也是挺想试下自己的能力。 于是，不知哪里来的蜜汁自信，熬测是周五的晚上，我周四的早晨第一次打开了OC基础教程这本书，然后高高兴兴的去赴死。 神奇的是，熬测的OC并没有太难为我，居然收到了最后的面试通知。 最后，还侥幸过了面试。 实习期的我一开始真是没有想到，联创还有如此漫长的实习期。 第一次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 OC基础薄弱，从来没有用纯代码写过项目，各种UI全然不熟悉。直到我看到了一本好书《Copying and pasting from stack overflow》,瞬间打开了新世界的大门。 然后这里贴贴那里补补终于搞定了任务。 第二次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 还记得当时直接理解错了任务，没有用Cell实现，于是，用一天的时间《重构——删除所有代码》，苦于没有美工，自己一点点的贴图，一点点的调整（不得不吐槽，纯代码写UI实在是太狗血了）， 经过了第130次微调，终于有了下面的丑态。 第三次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 写一个聊天机器人！！我对于网络的知识几乎为0，完全不知道从哪里下手。好在，有了一个月的时间，一个月的时间啊！ “慢慢磨，总是可以磨出来的吧”，我想。 显然，就像经典的电影桥段，我被打脸了。 对于聊天信息的显示，就耗费了我相当多的时间，头像 气泡 对话信息。。。一坨一坨的东西，完全没法驾驭。难以想象，当我实现一个黑白信息条的时候，有多么的兴奋。 “搞定了对话气泡，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我再次被打脸了。 网络的连接，又是一个大坑。POST请求，第一次崩溃，第二次崩溃。。。连Xcode编译器都被我搞了n次崩溃。。。 当控制台终于输出了正确的message时，感觉自己掌握了世界大门的钥匙。 “搞定了网络，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我又一次被打脸。 数据库的储存，也是个棘手的问题。当我自己都能背下来存储的数据时，手机就是显示为nil。一次nil，两次nil。。。无尽的空虚。最后才实现了数据的存储功能。 ”搞定了数据，之后的应该好写了吧“，我想。 显然，你知道我要说什么了。 调节UI简直有毒。“一个像素，再移动一个像素吧。”每次都这么说。 最后的最后，呈现了这种效果。 HackDay的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 其实，一开始我并不是特别想参与，感觉寒假有时间能自我充(f\u0001a\u0001ng)实(song)，然后发烧+重感冒，感觉身体被掏空。当我接触到项目的时候，发现我一开始的想法，是对的。PM要求的东西，之前的任务里面根本没有接触过，《iOS开发——从入门到绝望》。 但是，随着一点点的交流沟通，发现组队写一个项目是一件很美好的事情。尤其是有PM和两个Lab组的dalao，自己上传照片的请求被接受，觉得特别有成就感。也感受到了Deadline的刺激，直到最后的一秒钟，才输出了正确的匹配结果。 附上丑图。 致改变的我 “不努力一把，都不知道自己有多菜。” 一个学期，点点滴滴，我终于从一个什么都不懂的小白，变成了一个懂一点东西的小白。 细细想来，自己真的提升了很多。不仅仅是打字的速度，Google的能力，甚至也不仅仅是debug的能力，coding的能力，项目架构的能力。而是对于未知问题的探索能力，每一次的task，都是一次对自己的挑战，“如何利用Deadline提高生产力“，这才是真正的提升。 在和dalao交流的时候，发现了自己特别多的不足。我又想起了马克思主义基本原理的否定之否定规律。每周一次的Meet Up，都是一次对自我的否定，也是我前进发展的动力。从发现自己不会debug，到发现自己不会写代码，之后发现自己不懂计算机，最后怀疑自己是不是只会开机关机。每一次都是绝望再绝望的过程。 致现在的我 “明天的我会不会比今天更强？” 感谢周围的dalao，感谢UniqueStudio这个团队，感谢自己当初的决定和之后的自我否定，感谢自己没有虚度又一个学期。 回忆了过去这么多我，开始对下一年的我，下一月的我，下一周的我，下一刻的我，又有了些期待。 明天的我会不一样吗？ 当然，因为那就是我。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"},{"name":"联创","slug":"联创","permalink":"http://yoursite.com/tags/联创/"}]},{"title":"小小Q","date":"2017-01-20T00:22:00.000Z","path":"2017/01/20/Wetalk/","text":"小小Q基于Objective-C纯代码的实时聊天应用，使用图灵机器人API接口并支持图片搜索等多种模式的对话沟通。支持本地推送 3D-Touch等等功能。 简介我的第一个成型的APP，开发的第一步。 图片预览","tags":[]},{"title":"Hello World","date":"2017-01-19T13:27:47.000Z","path":"2017/01/19/Hello World/","text":"Hello World Stay Single, Stay Simple 12345#include&lt;stdio.h&gt;int main (int argc, char *argv[])&#123; printf(\"Hello, World!\\n\");&#125; 极客到极致 欢迎访问我的Github","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]}]