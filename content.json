[{"title":"差分约束系统","date":"2018-01-24T09:51:03.626Z","path":"2018/01/24/差分约束系统/","text":"差分约束系统问题描述首先先引入一个通用的线性规划问题，给定一个$m \\times n$的矩阵A，一个$m$维的向量$b$和一个$n$维向量$c$。希望能够找到一个$n$维的向量$x$，使得在由$Ax \\leqslant b$给定的$m$个约束条件下优化目标函数$\\sum_{i = 1}^n c_ix_i$，使得目标函数的取值最大。有时，我们并不关心目标函数，而是仅仅希望能找到一个可行解，即找到任何满足$Ax \\leqslant b$的向量$x$，或者判断不存在可行解。 观察一个特例情况，如果线性规划的矩阵$A$的每一行包括一个1和一个-1，其他的所有项皆为0。则对于$Ax \\leqslant b$所给出的约束条件变为$m$个涉及$n$个变量的差额限制条件，此时每个约束条件退化为简单的线性不等式：$x_j - x_i \\leqslant b_k$。这里$1 \\leqslant i, j \\leqslant n$，$i \\neq j$，且$1 \\leqslant k \\leqslant m$。 算法介绍问题建模对于此类问题，可以从图论的角度进行理解。 在一个$Ax \\leqslant b$的差分约束系统中，我们将$m \\times n$的线性规划矩阵$A$看作是一张由$n$个节点和$m$条边构成的图的邻接矩阵的转置。这里定义下约束图的概念： 约束图是一个带有权重的有向图$G = (V, E)$，这里 $V = {v_0, v_1, …, v_n }$，$E = {(v_i, v_j): x_j - x_i \\leqslant b_k } \\bigcup {(v_0, v_1), (v_0, v_2, …, (v_0, v_n)}$。 这里的$v_0$可以看作是一个额外的节点，用来保证图中至少有一个节点，并且从其出发可以到达所有的其他的节点。其中，如果$x_j - x_i \\leqslant b_k$是一个差分约束条件，则边$(v_i, v_j)$的权重为$w(v_i, v_j) = b_k$。 举例说明： 对于一组差分约束条件：$$\\begin{cases}x_1 - x_2 \\leqslant 0\\x_1 - x_5 \\leqslant -1\\x_2 - x_5 \\leqslant 1\\x_3 - x_1 \\leqslant 5\\x_4 - x_1 \\leqslant 4\\x_4 - x_3 \\leqslant -1\\x_5 - x_3 \\leqslant -3\\x_5 - x_4 \\leqslant -3\\\\end{cases}$$可以描绘出如下的差分约束系统的约束图： 其中，$(-5, -3, 0, -1, -4)$为满足条件的一个解。 不难发现，使用最短路算法中的松弛操作：$d(v) - d(u) \\leqslant w(u, v)$，刚好可以转为一个差分约束的条件：$i - j \\leqslant u$。于是，对于差分约束的问题，可以将未知数$x_i$对应一个顶点，将不等式$x_i - x_j \\leqslant c$转化为一条从$x_j$到$x_i$权值为$c$的边。 下面考虑两种特殊情况： 无解。当图中出现了负权环的时候，此时的最短路可以无限小，表现为$x_i - x_j \\leqslant c$中的$c$可以无限的小，所以满足条件的最大值不存在。 有无穷多解。当图中出现了不连通的情况，即起点$s$到终点$t$不可达，此时表示没有约束条件，即有无穷多的解。 求解方法对于一个最短路问题，经常使用$Dijkstra$算法或$Bellman-Ford$算法进行求解。如果转化的图中没有负权值的边，可以使用复杂度更低的$Dijkstra$算法进行计算。如果存在负权值的情况，当然可以通过$Bellman-Ford$算法进行判断，但是此算法的复杂度是$O(mn)$，我们这里使用改进版的$SPFA$算法进行求解。 12345678910111213141516171819202122bool spfa(s) for i from 0 to n - 1 d[i] = (i == s) ? 0 : INF; inq[i] = (i == s); // 入队列标记 visitCount[i] = 0; // 对负权环进行判断 q.push( (d[s], s) ); while( !q.empty() ) (dist, u) = q.pop(); // 取首元素 inq[u] = false; if( visitCount[u]++ &gt; n ) // 存在负权环 return true; for u 出发的所有的边 e v = edge[e].v; w = edge[e].w; if(d[u] + w &lt; d[v]) d[v] = d[u] + w; // 松弛操作 if ( !inq[v] ) inq[v] = true; q.push( (d[v], v) ); return false; 解题报告Poj 3159 Candies问题描述During the kindergarten days, flymouse was the monitor of his class. Occasionally the head-teacher brought the kids of flymouse’s class a large bag of candies and had flymouse distribute them. All the kids loved candies very much and often compared the numbers of candies they got with others. A kid A could had the idea that though it might be the case that another kid B was better than him in some aspect and therefore had a reason for deserving more candies than he did, he should never get a certain number of candies fewer than B did no matter how many candies he actually got, otherwise he would feel dissatisfied and go to the head-teacher to complain about flymouse’s biased distribution. snoopy shared class with flymouse at that time. flymouse always compared the number of his candies with that of snoopy’s. He wanted to make the difference between the numbers as large as possible while keeping every kid satisfied. Now he had just got another bag of candies from the head-teacher, what was the largest difference he could make out of it? Input The input contains a single test cases. The test cases starts with a line with two integers N and M not exceeding 30 000 and 150 000 respectively. N is the number of kids in the class and the kids were numbered 1 through N. snoopy and flymouse were always numbered 1 and N. Then follow M lines each holding three integers A, B and c in order, meaning that kid A believed that kid Bshould never get over c candies more than he did. Ouput Output one line with only the largest difference desired. The difference is guaranteed to be finite. 算法设计可以看出，每一个孩子在心里对于“公平”都有不同的界定，可以用一个不等式来描述他们每个人能够容忍的最大的差异性对待。 比如$1\\ 2\\ 5$表述了孩子$1$能够容忍孩子$2$比自己多$5$块糖果。那么可以表达为：$x_2 - x_1 \\leqslant 5$，对应到图上是一个从点$x_1$到点$x_2$的一个权值为$5$的边。 分析可知，这里的所有权值都为正数，可以直接使用$Dijkstra$进行编写。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 30000 + 10;const int MAXM = 150000 + 10;const int INF = 0x3f3f3f3f;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;struct Pair &#123; int v; int w; Pair(int _v, int _w): v(_v), w(_w) &#123;&#125;&#125;;struct Cmp &#123; bool operator() (const Pair&amp; lhs, const Pair&amp; rhs) &#123; return lhs.w &gt; rhs.w; &#125;&#125;;int n, m;int u, v, w;int d[MAXN];bool visited[MAXN];void dijkstra(int s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; visited[i] = false; &#125; priority_queue&lt;Pair, vector&lt;Pair&gt;, Cmp&gt;q; q.push(Pair(s, 0)); visited[s] = true; d[s] = 0; while (!q.empty()) &#123; Pair current = q.top(); if (current.v == n) return; q.pop(); visited[current.v] = true; for (int i = head[current.v]; i != 0; i = edge[i].next) &#123; if (visited[edge[i].to]) continue; if (d[current.v] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current.v] + edge[i].w; q.push(Pair(edge[i].to, d[edge[i].to])); &#125; &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; dijkstra(1); printf(\"%d\\n\", d[n]);&#125; 性能分析此处使用了优先队列优化的$Dijkstra$算法，算法的复杂度为$O(E\\lg V)$，空间上使用了链式向前星，减少了建图$malloc$的开销，最后Poj上的开销为：空间 2432K，时间672MS。 编程技术技巧 在建图的过程中，如果使用临接矩阵的结构，则空间开销为$O(n^2)$。如果使用临接表结构，此时很难估计规模，需要产生$malloc$的开销。这里使用了链式向前星，预先根据输入的规模开辟数组，通过链表的形式，将边储存下来，进行同时保证了访问的快捷性。 $Dijkstra$算法可以通过判断是否已经在$V$集合中进行剪枝的操作，避免不必要的运算。经对比发现，速度增加了$100\\%$。 Poj 1275 Cashier Employment问题描述A supermarket in Tehran is open 24 hours a day every day and needs a number of cashiers to fit its need. The supermarket manager has hired you to help him, solve his problem. The problem is that the supermarket needs different number of cashiers at different times of each day (for example, a few cashiers after midnight, and many in the afternoon) to provide good service to its customers, and he wants to hire the least number of cashiers for this job. The manager has provided you with the least number of cashiers needed for every one-hour slot of the day. This data is given as R(0), R(1), …, R(23): R(0) represents the least number of cashiers needed from midnight to 1:00 A.M., R(1) shows this number for duration of 1:00 A.M. to 2:00 A.M., and so on. Note that these numbers are the same every day. There are N qualified applicants for this job. Each applicant i works non-stop once each 24 hours in a shift of exactly 8 hours starting from a specified hour, say ti (0 &lt;= ti &lt;= 23), exactly from the start of the hour mentioned. That is, if the ith applicant is hired, he/she will work starting from ti o’clock sharp for 8 hours. Cashiers do not replace one another and work exactly as scheduled, and there are enough cash registers and counters for those who are hired. You are to write a program to read the R(i) ‘s for i=0..23 and ti ‘s for i=1..N that are all, non-negative integer numbers and compute the least number of cashiers needed to be employed to meet the mentioned constraints. Note that there can be more cashiers than the least number needed for a specific slot. Input The first line of input is the number of test cases for this problem (at most 20). Each test case starts with 24 integer numbers representing the R(0), R(1), …, R(23) in one line (R(i) can be at most 1000). Then there is N, number of applicants in another line (0 &lt;= N &lt;= 1000), after which come N lines each containing one ti (0 &lt;= ti &lt;= 23). There are no blank lines between test cases. Output For each test case, the output should be written in one line, which is the least number of cashiers needed.If there is no solution for the test case, you should write No Solution for that case. 算法设计此题转化为图的分析过程比较复杂，首先已知量是$R_0, R1,\\dots, R{23}$表示从$0$开始到$23$点结束每个小时需要的员工数量，同时$B_0, B1, \\dots, B{23}$是从这一刻能够开始工作的人的数量，这个数据可以从应聘者这里获得。现在需要解决的问题是，如何求出每个时刻需要开始工作的人数。 如果我们使用$A_0, A1, \\dots, A{23}$表示在对应的时刻能够开始工作的人数，因为每个人一天可以工作$8$个小时，所以要考虑到工人跨天的情况，对于$i \\geqslant 7$的情况：$$A{i-7} + A{i -6} + A_{i - 5} + \\dots + A_i \\geqslant R_i$$对于$0 \\leqslant i &lt; 7$的情况：$$(A_0 + \\dots + Ai)+ (A{i + 17} + \\dots + A_{23}) \\geqslant R_i$$但是，仅仅这个约束条件是不够的，对于$i \\in [0, 24)$，我们还有：$$0 \\leqslant A_i \\leqslant B_i$$为了方便起见，可以使用$Si = \\sum{j = 0}^{i}A_j$来表示一段的和。 则上面的式子可以转化为：$$\\begin{cases}Si - S{i - 8} \\geqslant R_i &amp; i \\geqslant 7\\Si + S{23} - S_{i + 16} \\geqslant R_i &amp; 0 \\leqslant i &lt; 7\\0 \\leqslant Si - S{i - 1} \\leqslant Bi &amp; 0 \\leqslant i &lt; 24\\\\end{cases}$$就可以直接将这个式子转化为图进行计算，但是这里注意到，$S{23}$是一个未知量，所以这里需要进行枚举$S_{23}$的可能取值，选择一个能够满足条件最小的进行输出。 注意这里有点技巧，$S_{23}$虽然值不大，但是也是$O(n)$级别，和求职者的个数相关，所以可以采用二分查找的方法，将复杂度降低到$O(\\lg n)$。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000 + 10;const int MAXM = 2000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN; &#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;bool inQueue[MAXN];int d[MAXN];int visitedCnt[MAXN];int qTime;int m;int u, v, w;bool spfa(int s) &#123; for (int i = 1; i &lt;= 24; ++i) &#123; d[i] = INF; inQueue[i] = false; &#125; d[s] = 0; visitedCnt[s] = 1; inQueue[s] = true; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; if (visitedCnt[edge[i].to]++ &gt; 24) return false; inQueue[edge[i].to] = true; push(edge[i].to); &#125; &#125; &#125; &#125; return true;&#125;int R[25];int b[25];int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;qTime); while (qTime--) &#123; memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= 24; ++i) &#123; scanf(\"%d\", R + i); &#125; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;u); ++b[u + 1]; &#125; int res = 0; int l = 1, r = m; int middle; while (l &lt;= r) &#123; middle = (l + r) &gt;&gt; 1; memset(head, 0, sizeof(head)); cnt = h = t = 0; memset(visitedCnt, 0, sizeof(visitedCnt)); for (int i = 8; i &lt;= 24; ++i) &#123; addEdge(i, i - 8, -R[i]); &#125; for (int i = 1; i &lt;= 7; ++i) &#123; addEdge(i, i + 16, -R[i] + middle); &#125; for (int i = 1; i &lt;= 24; ++i) &#123; addEdge(i, i - 1, 0); addEdge(i - 1, i, b[i]); &#125; addEdge(24, 0, -middle); addEdge(0, 24, middle); if (spfa(0)) &#123; res = middle; r = middle - 1; &#125; else &#123; l = middle + 1; &#125; &#125; if (res) printf(\"%d\\n\", res); else printf(\"No Solution\\n\"); &#125;&#125; 性能分析由于$SPFA$的算法复杂度由论文可知为$O(kE)$，建图需要$O(n)$，而对于二分查找需要$O(\\lg n)$次，所以最后的复杂度是$O(n\\lg n)$。最后Poj上开销为空间188K，时间16MS。 编程技术技巧分配收银员这题，第一次使用了$SPFA$算法，在何时对于不可能的情况（即出现了负权的环）进行剪枝是十分重要的，我们可以在将点入队列前，进行检查，这样可以节省一定的开销。 同时正如前面讲过的，如果出现了一个有序的排列，并且我们需要对其进行搜索，那么此时使用二分法进行查找是十分高效的，必须要将二分法熟练的掌握。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"ASPLOS半日行","date":"2017-04-17T13:09:05.000Z","path":"2017/04/17/ASPLOS/","text":"ASPLOS半日行真是出乎意料，自己能以本科生的身份 体验了计算机顶级会议ASPLOS 2017 作为一个还在刷 CSAPP 的小白，十分幸运能够来到西安，和众多世界级的科学家坐在一起，聆听并感受CS最前沿的科技革新。在此，首先要感谢的是为我们争取机会的@石老师，以及同行的15级ACM班全体大佬们。 长安古风 一日看尽长安花 标志的大雁塔，东西两部的钟楼和鼓楼 厚重的西安城墙，依稀看到古都的影子 biangbiang面，羊肉泡馍，特色的西安小吃 粗犷的西北饮食风格，感受长安城独到的魅力 Main Conference开场第一次接触这种顶级的会议，没有想象中的严肃刻板。反而感受到了一种轻松融洽的气氛，周围就坐的人都非常友善亲切。 阿里的首席科学家周靖人开场讲解了阿里云的技术创新，不仅包括大数据和AI，还有各种交互式 流计算和图计算等等。在数据质量检测和机器学习方面，也有所涉及。 虽然关于技术讲解并没有想象中的高深莫测，但也足够窥见阿里背后的惊人的技术投入，我对于阿里的印象也从策划公司转变到了科技公司，感受到了企业对于世界计算机技术发展的强大推动力。 Lighting Session受制于现在的专业知识水平，如果说之前周靖人的演讲能够让我大体听懂，之后90秒一篇的paper对于我的确有些勉强。能够理解表达的中心含义实属不易，但是即便如此，还是能够感受到这些世界顶级的科研人员对于技术的热情。 像下面这位天生的演讲家。 初步接触到了世界最前沿的技术和发展方向，明白了现在计算机领域究竟在研究什么样的问题，以及问题背后的驱动力量。 Solution并不重要，motivation才是重中之重。 Best Paper很庆幸，在会议之前我们集体研究过上午很多paper的主题，基本上能够更随着主讲者的思路向前推进。个人当然对于会议提到Mallacc和RedSpy比较感兴趣，会议后也关注了RedSpy的开源项目。 虽然对于内部的实现方式仅仅一知半解，但是他们所解决的大问题，也都是我在学习过程中曾经有过的一些小想法。所以，灵感就在转瞬间，如何抓住，如何踏踏实实的研究下去，也是我以后要思考和为之奋斗的问题。 Lunch Time实话实说，这次我的注意力完全没有放在午餐上面。除了保持坐姿和吃相以外，所有的精力都放在了如何同周围的学术大牛交流上面。 坐在对面的是一位芝加哥大学的留学博士生，无奈我口语硬伤，使用纯英文沟通还是有很多词不达意的情况，最后干脆中英混杂聊了起来。虽然因为语言问题略显尴尬，但还是了解到了相当多的关于留学深造以及国外科研的情况，他也很坦然的教给了我一些关于国外学校和微软亚洲研究院的申请技巧。 当然我们还聊到了本科生的课程问题，他也说出了他的理解，认为没有必要追求最主流的技术，毕竟搞教学最前沿的不一定是最能够让人理解和接受，不然何不每天讲解两篇paper呢。当然，在午饭最后，我也得到了他的邮箱，希望以后能够继续交流。 当然，唯一遗憾的还是没能和斜对面的Best Paper的得主交流。确实，在如何套磁方面我还是一点不懂，口语也并不过关，失去了一些机会，这也是我之后努力的方向吧。 Summary西安的顶会之行真的收获了很多，虽然真正参会的只有半天，但是我也初次窥得了世界最前沿的技术究竟是什么样子；初次了解了计算机究竟应该去做什么，计算机的本质问题是什么；更重要的是能和一批最顶尖的研究者做在一起，去了解他们的研究方式和思维方式。越厉害的人越是谦虚，当一个真正的大牛能够face to face和你交流知识，这种欣喜可想而知。 ASPLOS之行给我心里种下了一颗种子 我已经迫不及待的看到他的生根 发芽 结果 希望这一天，并不遥远。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]},{"title":"2016 Summary","date":"2017-01-22T14:17:00.000Z","path":"2017/01/22/2016 Summary/","text":"2016 Summary一学期竟然过的这么快，真是难以想象。暮然回首时，仿佛还能看见昔日的我。 致往日的我 “ flag 就是用来被推翻的。” 报名时的我依稀记得大一军训的时候，听到了联创这个团队。 “他是联创dalao”，“卧槽，好牛逼啊”。 显然，就像经典的电影桥段，当我终于计划好要报名的时候，发现早就过了截止日期。 一转眼到了大二，在年级群里再一次听到了联创这个名字，仿佛冥冥的召唤，我不假思索的报了名。 显然，就像经典的电影桥段，这一次没有错过。 测试时的我其实我是很期待熬测的，一开始只是觉得好玩。毕竟之前写过一些iOS的App，也是挺想试下自己的能力。 于是，不知哪里来的蜜汁自信，熬测是周五的晚上，我周四的早晨第一次打开了OC基础教程这本书，然后高高兴兴的去赴死。 神奇的是，熬测的OC并没有太难为我，居然收到了最后的面试通知。 最后，还侥幸过了面试。 实习期的我一开始真是没有想到，联创还有如此漫长的实习期。 第一次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 OC基础薄弱，从来没有用纯代码写过项目，各种UI全然不熟悉。直到我看到了一本好书《Copying and pasting from stack overflow》,瞬间打开了新世界的大门。 然后这里贴贴那里补补终于搞定了任务。 第二次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 还记得当时直接理解错了任务，没有用Cell实现，于是，用一天的时间《重构——删除所有代码》，苦于没有美工，自己一点点的贴图，一点点的调整（不得不吐槽，纯代码写UI实在是太狗血了）， 经过了第130次微调，终于有了下面的丑态。 第三次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 写一个聊天机器人！！我对于网络的知识几乎为0，完全不知道从哪里下手。好在，有了一个月的时间，一个月的时间啊！ “慢慢磨，总是可以磨出来的吧”，我想。 显然，就像经典的电影桥段，我被打脸了。 对于聊天信息的显示，就耗费了我相当多的时间，头像 气泡 对话信息。。。一坨一坨的东西，完全没法驾驭。难以想象，当我实现一个黑白信息条的时候，有多么的兴奋。 “搞定了对话气泡，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我再次被打脸了。 网络的连接，又是一个大坑。POST请求，第一次崩溃，第二次崩溃。。。连Xcode编译器都被我搞了n次崩溃。。。 当控制台终于输出了正确的message时，感觉自己掌握了世界大门的钥匙。 “搞定了网络，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我又一次被打脸。 数据库的储存，也是个棘手的问题。当我自己都能背下来存储的数据时，手机就是显示为nil。一次nil，两次nil。。。无尽的空虚。最后才实现了数据的存储功能。 ”搞定了数据，之后的应该好写了吧“，我想。 显然，你知道我要说什么了。 调节UI简直有毒。“一个像素，再移动一个像素吧。”每次都这么说。 最后的最后，呈现了这种效果。 HackDay的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 其实，一开始我并不是特别想参与，感觉寒假有时间能自我充(f\u0001a\u0001ng)实(song)，然后发烧+重感冒，感觉身体被掏空。当我接触到项目的时候，发现我一开始的想法，是对的。PM要求的东西，之前的任务里面根本没有接触过，《iOS开发——从入门到绝望》。 但是，随着一点点的交流沟通，发现组队写一个项目是一件很美好的事情。尤其是有PM和两个Lab组的dalao，自己上传照片的请求被接受，觉得特别有成就感。也感受到了Deadline的刺激，直到最后的一秒钟，才输出了正确的匹配结果。 附上丑图。 致改变的我 “不努力一把，都不知道自己有多菜。” 一个学期，点点滴滴，我终于从一个什么都不懂的小白，变成了一个懂一点东西的小白。 细细想来，自己真的提升了很多。不仅仅是打字的速度，Google的能力，甚至也不仅仅是debug的能力，coding的能力，项目架构的能力。而是对于未知问题的探索能力，每一次的task，都是一次对自己的挑战，“如何利用Deadline提高生产力“，这才是真正的提升。 在和dalao交流的时候，发现了自己特别多的不足。我又想起了马克思主义基本原理的否定之否定规律。每周一次的Meet Up，都是一次对自我的否定，也是我前进发展的动力。从发现自己不会debug，到发现自己不会写代码，之后发现自己不懂计算机，最后怀疑自己是不是只会开机关机。每一次都是绝望再绝望的过程。 致现在的我 “明天的我会不会比今天更强？” 感谢周围的dalao，感谢UniqueStudio这个团队，感谢自己当初的决定和之后的自我否定，感谢自己没有虚度又一个学期。 回忆了过去这么多我，开始对下一年的我，下一月的我，下一周的我，下一刻的我，又有了些期待。 明天的我会不一样吗？ 当然，因为那就是我。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"},{"name":"联创","slug":"联创","permalink":"http://yoursite.com/tags/联创/"}]},{"title":"小小Q","date":"2017-01-20T00:22:00.000Z","path":"2017/01/20/Wetalk/","text":"小小Q基于Objective-C纯代码的实时聊天应用，使用图灵机器人API接口并支持图片搜索等多种模式的对话沟通。支持本地推送 3D-Touch等等功能。 简介我的第一个成型的APP，开发的第一步。 图片预览","tags":[]},{"title":"Hello World","date":"2017-01-19T13:27:47.000Z","path":"2017/01/19/Hello World/","text":"Hello World Stay Single, Stay Simple 12345#include&lt;stdio.h&gt;int main (int argc, char *argv[])&#123; printf(\"Hello, World!\\n\");&#125; 极客到极致 欢迎访问我的Github","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]}]