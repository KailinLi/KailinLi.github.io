[{"title":"LCA 与 RMQ 问题","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/LCA and RMQ/","text":"LCA and RMQ问题描述LCA问题，即最近公共祖先问题。(Lowest common ancestor) 指在一个树或者有向无环图中同时拥有v和w作为后代的最深的节点。在这里，定义一个节点也是其自己的后代，因此如果v是w的后代，那么w就是v和w的最近公共祖先。 RMQ问题，即范围最值查询问题。(Range Minimum Query) 针对数据集的一种条件查询。若给定一个数组$A[1, n]$范围最值查询指定一个范围条件$i$到$j$，要求取出$A[i, j]$中最大/小的元素。 特别的，如果$A$上，任意两个相邻元素相差为$\\pm1$，则称此$RMQ$问题为$\\pm1RMQ$问题。 算法介绍问题建模LCA问题对于一棵树而言，通过暴力的$DFS$计算总是可以求出一个可行的解出来。但是复杂度比较高，对于频繁的祖先查询很吃力。 这里介绍一种离线的查询方法，即在获得所有的询问情况以后，再进行查询的操作，这样可以按照树的$DFS$的顺序进行查找，方便快速给出答案。不难发现，“公共祖先”也是一种关系，可以想到使用并查集的方法进行维护。如果在进行$DFS$访问的时候，使用并查集维护一个祖先关系，就可以离线的给出最后的答案。具体的实现可以参考下面的$Tarjan$离线算法。 RMQ问题对于另外一个问题，$RMQ$问题中，如果直接使用暴力的方法复杂度是$O(n^3)$，即对于$n^2$个区间，进行一次遍历操作，是不可以接受的。这里我们通常使用$Tarjan$的$Sparse-Table$算法，预处理时间是$O(n\\lg n)$，但是查询时间只需要O(1)，而且常数很小。 我们使$d(i, j)$表示从$i$开始的，长度为$2^j$的一段元素中的最小值，则可以用递推的方法，进行计算$d(i, j)$：$d(i, j) = min { d(i, j - 1), d(i + 2^{j - 1}, j - 1) } $。 注意这里的$d$数组元素个数不超过$n\\lg n$，每一项都可以在常数的时间内计算完毕，所以总的时间是$O(n\\lg n)$。 查询操作就很简单了，我们令$k$为满足$2^k\\leqslant R -L+1$的最大整数，则以$L$开头，$R$结尾的两个长度为$2^k$的区间合起来就可以覆盖查询区间$[L, R]$。 RMQ和LCA的转化如果从一个更高的视角来看这个问题，其实$LCA$和$RMQ$之间存在着对应的关系，但是并不是那么明显。 $LCA$是在一棵树上找最近公共祖先，$RMQ$是在一个数组上找区间最值。$u, v$的最近公共祖先是$u$到$v$的简单路径经过节点中深度的最小值。通过$DFS$遍历，形成一个$DFS$序，这样处理得到的序列就可以作为一个$Path$数组，设$L_u$是$u$结点在$Path$中第一次出现的位置。那么$Path$从下标$L_u$到$L_v$经过的元素就是$u$到$v$的路径。在这个区间上查询深度最小的结点即可。 求解方法LCA问题正如前文提到的$Tarjan$算法，我们可以进行类似$DFS$的遍历，在遍历的过程中进行祖先的计算。 1234567891011121314void LCA(int u) &#123; ancestor[u] = u; for (u 的所有孩子节点 v) &#123; LCA(v); setUnion(u, v); ancestor[setFind(u)] = u; &#125; visited[u] = 1; for (和 u 有关的查询节点 v) &#123; if (visited[v]) &#123; find ancestor[setFind(v)] &#125; &#125;&#125; 如图，在$DFS$的遍历中，如果维护一个并查集，其中蓝色的部分为同一个祖先，紫色没有还没被更新完成。现在要查询黄色的节点，因为其没有子孙，所以直接进入查询过程，发现和图中蓝色的部分的公共祖先都是同样的（这张图里为其父节点）。所以可以直接给出正确的答案。但是如果查询其他没有加入并查集的节点，只能进行反向查询（比如$(u,v)$需要在$(v, u)$处查询），所以问题必须要正反向加入两次，最后一定可以给出答案。 RMQ问题$RMQ$算法实现十分的简单，其代码也很短，这里直接给出代码： 12345678void RMQ_init (vector&lt;int&gt; &amp;A) &#123; // RMQ建表 int n = A.size(); for (int i = 0; i &lt; n; ++i) d[i][0] = A[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; ++i) d[i][j] = min(d[i][j - 1], d[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; 12345int RMQ (int L, int R) &#123; // 查询 int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= R - L + 1) ++k; return min(d[L][K], d[R - (1 &lt;&lt; k) + 1][k]);&#125; 解题报告Poj 1470 Closest Common Ancestors问题描述Write a program that takes as input a rooted tree and a list of pairs of vertices. For each pair (u,v) the program determines the closest common ancestor of u and v in the tree. The closest common ancestor of two nodes u and v is the node w that is an ancestor of both u and v and has the greatest depth in the tree. A node can be its own ancestor (for example in Figure 1 the ancestors of node 2 are 2 and 5) Input The data set, which is read from a the std input, starts with the tree description, in the form: nr_of_verticesvertex:(nr_of_successors) successor1 successor2 … successorn…where vertices are represented as integers from 1 to n ( n &lt;= 900 ). The tree description is followed by a list of pairs of vertices, in the form:nr_of_pairs(u v) (x y) … The input file contents several data sets (at least one).Note that white-spaces (tabs, spaces and line breaks) can be used freely in the input. Output For each common ancestor the program prints the ancestor and the number of pair for which it is an ancestor. The results are printed on the standard output on separate lines, in to the ascending order of the vertices, in the format: ancestor:timesFor example, for the following tree: 算法设计此题比较简单，基本就是$LCA$算法的简单应用。因为是离线算法，所以我们需要将询问的进行储存，最后一并输出。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 1000 + 10;int father[MAXN];int Rank[MAXN];int visited[MAXN];int ancestor[MAXN];int res[MAXN];vector&lt;int&gt; son[MAXN];vector&lt;int&gt; q[MAXN];int n;int setFind(int u) &#123; if (father[u] == u) return u; father[u] = setFind(father[u]); return father[u];&#125;void setUnion(int u, int v) &#123; u = setFind(u); v = setFind(v); if (u == v) return; if (Rank[v] &gt; Rank[u]) &#123; father[u] = v; Rank[v] += Rank[u]; &#125; else &#123; father[v] = u; Rank[u] += Rank[v]; &#125;&#125;void LCA(int u) &#123; ancestor[u] = u; for (vector&lt;int&gt;::iterator v = son[u].begin(); v != son[u].end(); ++v) &#123; LCA(*v); setUnion(u, *v); ancestor[setFind(u)] = u; &#125; visited[u] = 1; for (vector&lt;int&gt;::iterator v = q[u].begin(); v != q[u].end(); ++v) &#123; if (visited[*v]) &#123; ++res[ancestor[setFind(*v)]]; &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d\", &amp;n) == 1) &#123; int u, v; int i; for (i = 1; i &lt;= n; ++i) &#123; father[i] = i; son[i].clear(); q[i].clear(); &#125; memset(Rank, 1, sizeof(Rank)); memset(visited, 0, sizeof(visited)); memset(ancestor, 0, sizeof(ancestor)); memset(res, 0, sizeof(res)); for (i = 1; i &lt;= n; ++i) &#123; int sonCnt; scanf(\"%d:(%d)\", &amp;u, &amp;sonCnt); while(sonCnt--) &#123; scanf(\"%d\", &amp;v); ++res[v]; son[u].push_back(v); &#125; &#125; int qCnt; scanf(\"%d\", &amp;qCnt); while(qCnt--) &#123; scanf(\" (%d %d)\", &amp;u, &amp;v); q[u].push_back(v); q[v].push_back(u); &#125; for (i = 1; i &lt;= n; ++i) &#123; if (!res[i]) break; &#125; memset(res, 0, sizeof(res)); LCA(i); for (i = 1; i &lt;= n; ++i) &#123; if (res[i]) printf(\"%d:%d\\n\", i, res[i]); &#125; &#125;&#125; 性能分析题目基本是裸的$LCA$最后的复杂度是$O(n + q)$。 编程技术技巧此题基本没有太多技巧，唯一需要注意的是找到祖先以后，需要将数据保存下来，最后一并输出。 Poj 1986 Distance Queries问题描述Farmer John’s cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in “Navigation Nightmare”,followed by a line containing a single integer K, followed by K “distance queries”. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ’s distance queries as quickly as possible! Input Lines 1..1+M: Same format as “Navigation Nightmare” Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000 Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms. Output Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance. 算法设计题目也比较简单，基本可以看作是普通的$LCA$问题的求解，但是需要注意的是，我们需要求出两个点的路径长度，这里还是运用了求和的思想。通过一次$DFS$的遍历，指定编号的同时，记录每个点到根节点的距离。这样，如果需要计算$i$和$j$点的距离，我们只需要通过$distance(i) + distance(j) - 2 * distance(ancestor(i, j))$来进行计算。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;struct Edge &#123; int v; int d; Edge(int v, int d): v(v), d(d) &#123;&#125;&#125;;struct Question &#123; int v; int time; Question(int v, int t): v(v), time(t) &#123;&#125;&#125;;const int MAXN = 40000 + 10;int father[MAXN];int Rank[MAXN];int visited[MAXN];int ancestor[MAXN];int firstFind[MAXN];vector&lt;Edge&gt; son[MAXN];vector&lt;Question&gt; q[MAXN];int Distance[MAXN];int res[MAXN];int n, m, u, v, d, i;int setFind(int u) &#123; if (father[u] == u) return u; father[u] = setFind(father[u]); return father[u];&#125;void setUnion(int u, int v) &#123; u = setFind(u); v = setFind(v); if (u == v) return; if (Rank[v] &gt; Rank[u]) &#123; father[u] = v; Rank[v] += Rank[u]; &#125; else &#123; father[v] = u; Rank[u] += Rank[v]; &#125;&#125;void LCA(int u, int sumDistance) &#123; ancestor[u] = u; Distance[u] = sumDistance; firstFind[u] = 1; for (vector&lt;Edge&gt;::iterator v = son[u].begin(); v != son[u].end(); ++v) &#123; if (firstFind[v-&gt;v]) continue; LCA(v-&gt;v, v-&gt;d + sumDistance); setUnion(u, v-&gt;v); ancestor[setFind(u)] = u; &#125; visited[u] = 1; for (vector&lt;Question&gt;::iterator v = q[u].begin(); v != q[u].end(); ++v) &#123; if (visited[v-&gt;v]) &#123; res[v-&gt;time] = Distance[u] + Distance[v-&gt;v] - (Distance[ancestor[setFind(v-&gt;v)]] &lt;&lt; 1); &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d\", &amp;n, &amp;m) == 2) &#123; for (i = 1; i &lt;= n; ++i) &#123; father[i] = i; son[i].clear(); q[i].clear(); &#125; memset(Rank, 1, sizeof(int) * n + 1); memset(visited, false, sizeof(int) * n + 1); memset(firstFind, 0, sizeof(int) * n + 1); char tmp[10]; while (m--) &#123; scanf(\"%d %d %d %s\", &amp;u, &amp;v, &amp;d, tmp); son[u].push_back(Edge(v, d)); son[v].push_back(Edge(u, d)); &#125; scanf(\"%d\", &amp;m); for (i = 0; i &lt; m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); q[u].push_back(Question(v, i)); q[v].push_back(Question(u, i)); &#125; LCA(1, 0); for (i = 0; i &lt; m; ++i) &#123; printf(\"%d\\n\", res[i]); &#125; &#125;&#125; 性能分析此题和上一道题目区别不是很大，主要是需要事先计算开始的$DFS$序列，花费时间是$O(n)$。所以基本的复杂度和$LCA$一致，为$O(n\\lg n)$。 编程技术技巧此题比较直接，和在树状数组里遇到的题目基本一致，没有太多的技巧可以介绍。 Poj 2763 Housewife Wind问题描述After their royal wedding, Jiajia and Wind hid away in XX Village, to enjoy their ordinary happy life. People in XX Village lived in beautiful huts. There are some pairs of huts connected by bidirectional roads. We say that huts in the same pair directly connected. XX Village is so special that we can reach any other huts starting from an arbitrary hut. If each road cannot be walked along twice, then the route between every pair is unique. Since Jiajia earned enough money, Wind became a housewife. Their children loved to go to other kids, then make a simple call to Wind: ‘Mummy, take me home!’ At different times, the time needed to walk along a road may be different. For example, Wind takes 5 minutes on a road normally, but may take 10 minutes if there is a lovely little dog to play with, or take 3 minutes if there is some unknown strange smell surrounding the road. Wind loves her children, so she would like to tell her children the exact time she will spend on the roads. Can you help her? Input The first line contains three integers n, q, s. There are n huts in XX Village, q messages to process, and Wind is currently in hut s. n &lt; 100001 , q &lt; 100001. The following n-1 lines each contains three integers a, b and w. That means there is a road directly connecting hut a and b, time required is w. 1&lt;=w&lt;= 10000. The following q lines each is one of the following two types: Message A: 0 uA kid in hut u calls Wind. She should go to hut u from her current position.Message B: 1 i wThe time required for i-th road is changed to w. Note that the time change will not happen when Wind is on her way. The changed can only happen when Wind is staying somewhere, waiting to take the next kid. Output For each message A, print an integer X, the time required to take the next child. 算法设计此题算法设计很复杂，恰好用到了前文提出的各个要点，在这里使用$ST$算法进行计算，通过$DFS$序转化，最后用$LCA$转$RMQ$进行查询。和上一题一样，仍然需要使用$distance(i) + distance(j) - 2 * distance(ancestor(i, j))$的思想进行处理，但是因为母亲的位置是移动的，如果使用在线算法，对于这道题目来说会比较方便。所以需要使用一个树状数组，进行$O(\\lg n)$的求和操作。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int BIT[MAXN &lt;&lt; 1];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt; (MAXN &lt;&lt; 1)) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;struct Edge &#123; int to; int next;&#125;;Edge edge[MAXN * 2];int edgeWeight[MAXN];int head[MAXN];int cntEdge;inline void addEdge(int u, int v) &#123; edge[++cntEdge].to = v; edge[cntEdge].next = head[u]; head[u] = cntEdge;&#125;int id[MAXN * 2], idToPoint[MAXN * 2];int depth[MAXN * 2];int cnt;int in[MAXN], out[MAXN];void dfs(int u, int d, int father) &#123; id[u] = ++cnt; idToPoint[cnt] = u; depth[cnt] = d; for (int i = head[u]; i != 0; i = edge[i].next) &#123; if (edge[i].to == father) continue; int edgeId = (i + 1) &gt;&gt; 1; edit(cnt + 1, edgeWeight[edgeId]); in[edgeId] = cnt + 1; dfs(edge[i].to, d + 1, u); idToPoint[++cnt] = u; edit(cnt, -edgeWeight[edgeId]); out[edgeId] = cnt; depth[cnt] = d; &#125;&#125;int dp[MAXN * 2][20];int cmp(int x, int y) &#123; return depth[x] &lt; depth[y];&#125;void ST(int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = i; &#125; int len = (int)(log(n * 1.0) / log(2.0)); for (int j = 1; j &lt;= len; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (i + (1 &lt;&lt; j) - 1 &gt; n) break; dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1], cmp); &#125; &#125;&#125;int RMQ(int x, int y) &#123; if (x &gt; y) swap(x, y); int k = (int)(log(y - x + 1.0) / log(2.0)); return min(dp[x][k], dp[y + 1 - (1 &lt;&lt; k)][k], cmp);&#125;int LCA(int u, int v) &#123; return idToPoint[RMQ(id[u], id[v])];&#125;int n, mother, state, childCall, num, delta, qtimes;int u, v;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while(scanf(\"%d %d %d\", &amp;n, &amp;qtimes, &amp;mother) == 3) &#123; memset(dp, 0, sizeof(dp)); memset(BIT, 0, sizeof(BIT)); memset(head, 0, sizeof(head)); cnt = 0; cntEdge = 0; for (int i = 1; i &lt;= n - 1; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, edgeWeight + i); addEdge(u, v); addEdge(v, u); &#125; dfs(1, 1, -1); ST((n &lt;&lt; 1) - 1); while(qtimes--) &#123; scanf(\"%d\", &amp;state); if (state) &#123; scanf(\"%d %d\", &amp;num, &amp;delta); edit(in[num], delta - edgeWeight[num]); edit(out[num], edgeWeight[num] - delta); edgeWeight[num] = delta; &#125; else &#123; scanf(\"%d\", &amp;childCall); int root = LCA(mother, childCall); printf(\"%d\\n\", sum(id[mother]) + sum(id[childCall]) - (sum(id[root]) &lt;&lt; 1)); mother = childCall; &#125; &#125; &#125;&#125; 性能分析通过$DFS$将$LCA$问题转化为$RMQ$问题是$O(n)$级别的算法，对于$RMQ$本身来说，需要进行$O(n\\lg n)$的时间进行建表的操作，树状数组的查询也是$O(\\lg n)$级别的，所以考虑有$n$次的查询，总体的复杂度是$O(n\\lg n)$。 编程技术技巧题目本身比较复杂，融合的内容比较多，需要对于修改-查询这一类的算法都比较清楚熟练，才能比较好的完成此题。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"线段树","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/Segment Tree/","text":"Segment Tree问题描述首先，回到树状数组的问题： 给定$n$个数字，有两种频繁的操作需要处理： 求$\\sum_{k = i}^j A_k$； 对某个$A_i$数据进行增减操作。 对于这种情况，使用树状数组肯定是十分方便的，而且编程十分的简单。 但是如果题目的要求更加的灵活，树状数组在很多的情况下是不适和的。(或者更准确的说，对设计技巧要求更高) 现在需要有一个支持区间更新、区间查询等等操作的数据结构，并且要保证每个操作基本可以在$O(\\lg n)$的时间完成。 于是我们引入了线段树的数据结构。通过将整体区间进行分割，由叶节点管理最小的分割单元，其他节点以类似$2^k$的形式逐层进行管理。 算法介绍问题建模类似区间树，在各个节点保存一条线段（数组中的一段子数组），可以高效解决连续区间的动态查询问题，由于二叉结构的特性。 线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是$[a, b]$，那么$mid = \\frac{a+b}{2}$，左儿子的区间是$[a, mid]$，右儿子的区间是$[mid + 1, b]$。 于是，当我们需要查询一段数据的时候，只需要查询对应的大区间即可，而不用一个点一个点的查询。如下图所示： 如果我们需要查询$[0, 3]$上的最值，我们不需要查找$3$次找到结果，只要按照$2^k$的顺序，依次查找$[0, 2]$和$[3, 3]$即可。 对于修改的问题，处理比较特殊。理论上，我们必须要将每个点的值进行修改以后，再重新更新它的所有的祖先节点。但是这样以来，复杂度就是$O(n\\lg n)$了，不符合我们的要求。 考虑一种方法，如果我们几乎每次都访问一个长区间，是不是最小的叶子节点上的值就不重要了呢？换句话说，如果操作都是基于长区间的，我们可以把这些区间当作是一个叶节点来进行操作。只要每次都修改这个区间的数值就好。 但是这样一来，访问单点就会出问题，所以我们可以使用一个“$lazy$的思想”：如果访问的区间刚好在包括了这个点代表的整个区间，我们就不需要向下继续的修改。只要使用一个$lazy$的标记，表示这个区间下面的点，还没有被修改，如果希望访问，请先修改后再访问；如果不需要继续访问它的孩子，修改的操作仍然可以延后。 求解方法线段树的代码针对不同问题有多种写法，但是基本的思想都是一致的。 先引入$pushUp$和$pushDown$两种思想，即根据子节点修改父节点和根据父节点$lazy$的标记修改子节点。 123void pushUp(int root) &#123; Tree[root] = Tree[root &lt;&lt; 1] op Tree[root &lt;&lt; 1 | 1]; // op是针对问题的某种操作&#125; 123456789101112void pushDown(int root) &#123; if (!lazy[root]) return; // 如果不需要修改 Tree[root &lt;&lt; 1] op= Tree[root]; Tree[root &lt;&lt; 1 | 1] op= Tree[root]; // 左右儿子根据父节点变化 /* ** 标记子节点并取消父节点标记 */ lazy[root &lt;&lt; 1] = 1; lazy[root &lt;&lt; 1 | 1] = 1; lazy[root] = 0;&#125; 下面我们可以使用递归的方法进行建树： 12345678910void buildTree(int l, int r, int root) &#123; if (l == r) &#123; Tree[root] = 1; // 子节点 return; &#125; int m = (l + r) &gt;&gt; 1; buildTree(l, m, root &lt;&lt; 1); buildTree(m + 1, r, root &lt;&lt; 1 | 1); pushUp(root);&#125; 对于修改操作，需要灵活的运用$lazy$的思想，下面的代码仅仅给出例子，但是具体何时进行修改，需要针对具体的题目来定。 1234567891011121314void updateTree(int L, int R, int delta, int l, int r, int root) &#123; if (r &lt; L || l &gt; R) return; else if (r &lt;= R &amp;&amp; l &gt;= L) &#123; lazy[root] = 1; Tree[root] = delta; return; &#125; pushDown(root); int m = (l + r) &gt;&gt; 1; updateTree(L, R, delta, l, m, root &lt;&lt; 1); updateTree(L, R, delta, m + 1, r, root &lt;&lt; 1 | 1); pushUp(root);&#125; 查询比较简单，注意如果要求查询的区间比较小，需要将现在的区间进行划分以后才能查询的话，我们必须要在下一次递归查询之前，通过$pushDown$的操作，将$lazy$标记向下传播，否则会查询出错。 12345678910int queryTree(int L, int R, int l, int r, int root) &#123; if (r &lt; L || l &gt; R) return 0; else if (r &lt;= R &amp;&amp; l &gt;= L ) &#123; return Tree[root]; &#125; pushDown(root); int m = (l + r) &gt;&gt; 1; return queryTree(L, R, l, m, root &lt;&lt; 1) | queryTree(L, R, m + 1, r, root &lt;&lt; 1 | 1);&#125; 解题报告Poj 2777 Count Color问题描述Chosen Problem Solving and Program design as an optional course, you are required to solve all kinds of problems. Here, we get a new problem. There is a very long board with length L centimeter, L is a positive integer, so we can evenly divide the board into L segments, and they are labeled by 1, 2, … L from left to right, each is 1 centimeter long. Now we have to color the board - one segment with only one color. We can do following two operations on the board: “C A B C” Color the board from segment A to segment B with color C. “P A B” Output the number of different colors painted between segment A and segment B (including). In our daily life, we have very few words to describe a color (red, green, blue, yellow…), so you may assume that the total number of different colors T is very small. To make it simple, we express the names of colors as color 1, color 2, … color T. At the beginning, the board was painted in color 1. Now the rest of problem is left to your. Input First line of input contains L (1 &lt;= L &lt;= 100000), T (1 &lt;= T &lt;= 30) and O (1 &lt;= O &lt;= 100000). Here O denotes the number of operations. Following O lines, each contains “C A B C” or “P A B” (here A, B, C are integers, and A may be larger than B) as an operation defined previously. Output Ouput results of the output operation in order, each line contains a number. 算法设计这道题目很明显是通过线段树进行区间的查询修改，所以我们可以对于每一个节点，除了叶节点以外，维护一个30个元素的数组，记录自己的孩子节点里面都哪些颜色。 但是，虽然Poj上给的空间比较多，但是还是显得比较笨拙，所以我们可以使用位操作。因为一个$int$刚好是$4$字节，即$32$位，所以只要一个$int$型的数就可以记录下所有的颜色。 其余的操作就是标准的线段树的写法。注意，因为区间修改是把区间里面的点全部修改为一种颜色，所以在进行$pushDown$的操作的时候，只需要让子节点和父节点的颜色相同，就可以了。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 131072 + 10;int color[MAXN &lt;&lt; 1];int lazy[MAXN &lt;&lt; 1];inline void pushUp(int root) &#123; color[root] = color[root &lt;&lt; 1] | color[root &lt;&lt; 1 | 1];&#125;inline void pushDown(int root) &#123; if (!lazy[root]) return; color[root &lt;&lt; 1] = color[root]; color[root &lt;&lt; 1 | 1] = color[root]; lazy[root &lt;&lt; 1] = 1; lazy[root &lt;&lt; 1 | 1] = 1; lazy[root] = 0;&#125;void buildTree(int l, int r, int root) &#123; if (l == r) &#123; color[root] = 1; return; &#125; int m = (l + r) &gt;&gt; 1; buildTree(l, m, root &lt;&lt; 1); buildTree(m + 1, r, root &lt;&lt; 1 | 1); pushUp(root);&#125;void updateTree(int L, int R, int delta, int l, int r, int root) &#123; if (r &lt; L || l &gt; R) return; else if (r &lt;= R &amp;&amp; l &gt;= L) &#123; lazy[root] = 1; color[root] = delta; return; &#125; pushDown(root); int m = (l + r) &gt;&gt; 1; updateTree(L, R, delta, l, m, root &lt;&lt; 1); updateTree(L, R, delta, m + 1, r, root &lt;&lt; 1 | 1); pushUp(root);&#125;int queryTree(int L, int R, int l, int r, int root) &#123; if (r &lt; L || l &gt; R) return 0; else if (r &lt;= R &amp;&amp; l &gt;= L ) &#123; return color[root]; &#125; pushDown(root); int m = (l + r) &gt;&gt; 1; return queryTree(L, R, l, m, root &lt;&lt; 1) | queryTree(L, R, m + 1, r, root &lt;&lt; 1 | 1);&#125;int L, T, O;char input;int x, y, c;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d %d\", &amp;L, &amp;T, &amp;O); buildTree(1, L, 1); while (O--) &#123; getchar(); scanf(\"%c\", &amp;input); if (input == 'C') &#123; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;c); if (x &gt; y) swap(x, y); updateTree(x, y, 1 &lt;&lt; (c - 1), 1, L, 1); &#125; else &#123; scanf(\"%d %d\", &amp;x, &amp;y); if (x &gt; y) swap(x, y); int n = queryTree(x, y, 1, L, 1); int res = 0; for (int i = 0; n; ++i) &#123; res += n &amp; 1; n &gt;&gt;= 1; &#125; printf(\"%d\\n\", res); &#125; &#125;&#125; 性能分析之前已经分析过，线段树的操作复杂度是$O(\\lg n)$的，所以对于这道题目，时间的复杂度就是$O(n\\lg n)$。 编程技术技巧此题是第一道线段树的题目，主要有两个位操作值得一提： 访问子节点 因为子节点一定是父节点编号的$2$倍，所以如果线段树的储存从$1$开始，我们可以看出，通过一个位移的操作刚好可以访问到左节点：left = root&lt;&lt;1。对于右节点，理论上就是左节点$+1$，但是考虑到右移以后，最低位刚好为$0$，所以直接通过一个或运算，就可以加一：right = (root&lt;&lt;1)|1。 颜色的储存 这里的方法比较巧妙，通过每一位表示一个颜色，对最后的结果进行存储。其中，还可以比较方便的使用位操作的或进行颜色的加和。 Poj 1470 Closest Common Ancestors问题描述Farmer John has taken his cows on a trip to the city! As the sun sets, the cows gaze at the city horizon and observe the beautiful silhouettes formed by the rectangular buildings. The entire horizon is represented by a number line with N (1 ≤ N ≤ 40,000) buildings. Building i‘s silhouette has a base that spans locations Ai through Bi along the horizon (1 ≤ Ai &lt; Bi ≤ 1,000,000,000) and has height Hi (1 ≤ Hi ≤ 1,000,000,000). Determine the area, in square units, of the aggregate silhouette formed by all N buildings. Input Line 1: A single integer: NLines 2..N+1: Input line i+1 describes building i with three space-separated integers: Ai, Bi, and Hi Output Line 1: The total area, in square units, of the silhouettes formed by all N buildings 算法设计 如图，这道题目需要求出由建筑物组成的剪影，需要查询整个区间的剪影面积。 乍一看和线段树没有明显的关系，但是仔细分析：题目只涉及到面积的求解，所以不需要区分某一个具体的建筑。我们可以把每一段的高度通过线段树储存，最后每个区间进行分别的计算，最后求出总和。 但是此题的横坐标范围很大，如果直接使用线段树进行储存，空间开销过大。(注：根据二叉树的性质，叶节点和其余节点的个数相等)，所以理论上空间的开销是$2$倍的$n$，考虑到不是一个满的二叉树，空间开销有可能达到$4$倍的$n$节点。 所以，需要对于空间进行压缩，这里使用的还是和之前并查集的那个章节一样的$hash$映射的方法，通过一次$hash$的$map$操作，大大节省了空间。但是需要注意的是，这里的计算面积的时候，仍然需要将原先的数据映射回来进行计算。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef long long ll;const ll MAXN = 600000;map&lt;ll, ll&gt; hashMap;ll cnt;ll size;ll hashArray[MAXN];struct Question &#123; ll u; ll v; ll h;&#125;;Question question[MAXN];ll segTree[MAXN &lt;&lt; 2];bool lazy[MAXN];inline void pushUp(ll root) &#123; segTree[root] = max(segTree[root &lt;&lt; 1], segTree[root &lt;&lt; 1 | 1]);&#125;inline void pushDown(ll root) &#123; if (!lazy[root]) return; segTree[root &lt;&lt; 1] = max(segTree[root &lt;&lt; 1], segTree[root]); segTree[root &lt;&lt; 1 | 1] = max(segTree[root &lt;&lt; 1 | 1], segTree[root]); lazy[root &lt;&lt; 1] = true; lazy[root &lt;&lt; 1 | 1] = true; lazy[root] = false;&#125;void updateTree(ll L, ll R, ll h, ll l, ll r, ll root) &#123; if (r &lt; L || l &gt; R) return; else if (r &lt;= R &amp;&amp; l &gt;= L) &#123; lazy[root] = 1; segTree[root] = max(segTree[root], h); return; &#125; pushDown(root); ll m = (l + r) &gt;&gt; 1; updateTree(L, R, h, l, m, root &lt;&lt; 1); updateTree(L, R, h, m + 1, r, root &lt;&lt; 1 | 1);&#125;ll queryTree(ll L, ll R, ll l, ll r, ll root) &#123; pushDown(root); if (l == r) &#123; return segTree[root] * (hashArray[l + 1] - hashArray[l]); &#125; ll m = (l + r) &gt;&gt; 1; return queryTree(L, R, l, m, root &lt;&lt; 1) + queryTree(L, R, m + 1, r, root &lt;&lt; 1 | 1);&#125;ll n;ll u, v, h;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%lld\", &amp;n) == 1) &#123; cnt = 0; size = 0; hashMap.clear(); memset(segTree, 0, sizeof(segTree)); for (int i = 0; i &lt; MAXN; ++i) &#123; lazy[i] = false; &#125; while (n--) &#123; scanf(\"%lld %lld %lld\", &amp;u, &amp;v, &amp;h); if (u &gt; v) swap(u, v); question[++cnt].u = u; question[cnt].v = v; question[cnt].h = h; hashMap[u] = 0; hashMap[v] = 0; &#125; for (map&lt;ll, ll&gt;::iterator i = hashMap.begin(); i != hashMap.end(); ++i) &#123; i-&gt;second = ++size; hashArray[size] = i-&gt;first; &#125; for (int i = 1; i &lt;= cnt; ++i) &#123; updateTree(hashMap[question[i].u], hashMap[question[i].v] - 1, question[i].h, 1, size, 1); &#125; printf(\"%lld\\n\", queryTree(1, size, 1, size, 1)); &#125;&#125; 性能分析和之前一样，$n$次的插入操作使得时间复杂度变成$O(n\\lg n)$，对于$map$的映射而言，同样也是$O(n\\lg n)$的复杂度，所以总共的时间复杂度就是$O(n)$。对于空间来说，因为使用$hash$的方法，所以只和输入的大楼个数有关，复杂度是$O(n)$。 编程技术技巧这道题目仍然使用了$hash$映射的方式来节省空间，但是值得注意的是，此时线段树的空间大小不可以仅仅只是$n$，因为线段树在访问的时候，对于底层的节点仍然使用了递归的方法进行访问，所以如果空间没有开辟的足够大，有可能出现访问越界等等错误的情况。一般来说，$3$倍的空间是够用的。 Poj 3667 Hotel问题描述The cows are journeying north to Thunder Bay in Canada to gain cultural enrichment and enjoy a vacation on the sunny shores of Lake Superior. Bessie, ever the competent travel agent, has named the Bullmoose Hotel on famed Cumberland Street as their vacation residence. This immense hotel has N (1 ≤ N ≤ 50,000) rooms all located on the same side of an extremely long hallway (all the better to see the lake, of course). The cows and other visitors arrive in groups of size Di (1 ≤ Di ≤ N) and approach the front desk to check in. Each group i requests a set of Di contiguous rooms from Canmuu, the moose staffing the counter. He assigns them some set of consecutive room numbers r..r+Di-1 if they are available or, if no contiguous set of rooms is available, politely suggests alternate lodging. Canmuu always chooses the value of r to be the smallest possible. Visitors also depart the hotel from groups of contiguous rooms. Checkout i has the parameters Xi and Di which specify the vacating of rooms Xi ..Xi +Di-1 (1 ≤ Xi ≤ N-Di+1). Some (or all) of those rooms might be empty before the checkout. Your job is to assist Canmuu by processing M (1 ≤ M &lt; 50,000) checkin/checkout requests. The hotel is initially unoccupied. Input Line 1: Two space-separated integers: N and M Lines 2..M+1: Line i+1 contains request expressed as one of two possible formats: (a) Two space separated integers representing a check-in request: 1 and Di (b) Three space-separated integers representing a check-out: 2, Xi, and Di Output Lines 1…..: For each check-in request, output a single line with a single integer r, the first room in the contiguous sequence of rooms to be occupied. If the request cannot be satisfied, output 0. 算法设计Hotel题目比较复杂，主要体现在每个节点需要保存的数据比较多，每一次的$pushDown$和$pushUp$的操作过程稍微繁琐。 因为题目需要求出最大的连续区间满足房屋分配的条件，所以我们需要使用$3$个数据分别保存区间中最大的连续房间，从左边开始的连续房间，从右边向左开始的连续房间。为什么要保存这种数据呢？因为在进行区间和合并的时候，有可能新的大区间内，是由左节点的右边区间和右节点的左边区间合并拼凑起来的。所以需要进行一个比较。 剩余的操作和前面的题目基本一致，这里不再进行赘述。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 50000;struct SegTree &#123; int hole; int leftHole; int rightHole; int lazy;&#125;;SegTree segTree[MAXN &lt;&lt; 2];inline void pushUp(int root, int len) &#123; segTree[root].leftHole = segTree[root &lt;&lt; 1].leftHole; segTree[root].rightHole = segTree[root &lt;&lt; 1 | 1].rightHole; if (segTree[root].leftHole == len - (len &gt;&gt; 1)) segTree[root].leftHole += segTree[root &lt;&lt; 1 | 1].leftHole; if (segTree[root].rightHole == (len &gt;&gt; 1)) segTree[root].rightHole += segTree[root &lt;&lt; 1].rightHole; segTree[root].hole = max(segTree[root &lt;&lt; 1].rightHole + segTree[root &lt;&lt; 1 | 1].leftHole, max(segTree[root &lt;&lt; 1].hole, segTree[root &lt;&lt; 1 | 1].hole));&#125;inline void pushDown(int root, int len) &#123; if (segTree[root].lazy == -1) return; if (segTree[root].lazy) &#123; segTree[root &lt;&lt; 1].leftHole = segTree[root &lt;&lt; 1].rightHole = segTree[root &lt;&lt; 1].hole = len - (len &gt;&gt; 1); segTree[root &lt;&lt; 1 | 1].leftHole = segTree[root &lt;&lt; 1 | 1].rightHole = segTree[root &lt;&lt; 1 | 1].hole = len &gt;&gt; 1; &#125; else &#123; segTree[root &lt;&lt; 1].leftHole = segTree[root &lt;&lt; 1].rightHole = segTree[root &lt;&lt; 1].hole = 0; segTree[root &lt;&lt; 1 | 1].leftHole = segTree[root &lt;&lt; 1 | 1].rightHole = segTree[root &lt;&lt; 1 | 1].hole = 0; &#125; segTree[root &lt;&lt; 1].lazy = segTree[root &lt;&lt; 1 | 1].lazy = segTree[root].lazy; segTree[root].lazy = -1;&#125;void buildTree(int l, int r, int root) &#123; segTree[root].hole = segTree[root].leftHole = segTree[root].rightHole = r - l + 1; segTree[root].lazy = -1; if (l == r) return; int middle = (l + r) &gt;&gt; 1; buildTree(l, middle, root &lt;&lt; 1); buildTree(middle + 1, r, root &lt;&lt; 1 | 1);&#125;void updateTree(int L, int R, int delta, int l, int r, int root) &#123; if (r &lt; L || l &gt; R) return; else if (r &lt;= R &amp;&amp; l &gt;= L) &#123; segTree[root].hole = segTree[root].leftHole = segTree[root].rightHole = delta ? r - l + 1 : 0; segTree[root].lazy = delta; return; &#125; pushDown(root, r - l + 1); int middle = (l + r) &gt;&gt; 1; updateTree(L, R, delta, l, middle, root &lt;&lt; 1); updateTree(L, R, delta, middle + 1, r, root &lt;&lt; 1 | 1); pushUp(root, r - l + 1);&#125;int queryTree(int l, int r, int root, int q) &#123; if (l == r) return l; pushDown(root, r - l + 1); int middle = (l + r) &gt;&gt; 1; if (segTree[root &lt;&lt; 1].hole &gt;= q) return queryTree(l, middle, root &lt;&lt; 1, q); else if (segTree[root &lt;&lt; 1].rightHole + segTree[root &lt;&lt; 1 | 1].leftHole &gt;= q) return middle - segTree[root &lt;&lt; 1].rightHole + 1; else return queryTree(middle + 1, r, root &lt;&lt; 1 | 1, q);&#125;int n, m;int u, v, op;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d\", &amp;n, &amp;m) == 2) &#123; buildTree(1, n, 1); while (m--) &#123; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d\", &amp;u); if (segTree[1].hole &lt; u) printf(\"0\\n\"); else &#123; int pos = queryTree(1, n, 1, u); printf(\"%d\\n\", pos); updateTree(pos, pos + u - 1, 0, 1, n, 1); &#125; &#125; else &#123; scanf(\"%d %d\", &amp;u, &amp;v); updateTree(u, u + v - 1, 1, 1, n, 1); &#125; &#125; &#125;&#125; 性能分析题目虽然每一次的操作相对于前面复杂了不少，但是由于操作都是$O(1)$的比较操作，所以印象不大，仍然是$O(n\\lg n)$的复杂度。 编程技术技巧此题展现了线段树结构的强大之处，其节点内部可以储存很多的信息，在$pushDown$和$pushUp$的操作中，我们需要保证信息的正确性，使得线段树发挥很大的威力。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"后缀数组","date":"2018-01-26T13:14:29.948Z","path":"2018/01/26/Suffix Array/","text":"Suffix Array问题描述首先来考虑一个字符串匹配的问题。 假设文本是一个长度为$n$的字符串$T$，模版是一个长度为$m$的字符串$P$，并且$m \\leqslant n$。需要求出模版在文本中的所有匹配点$i$。如下图： 这个问题可以通过$KMP$算法解决。 但是如果匹配的模版有多个的时候，$KMP$算法不太合适，因为每次查找一个模版，都要遍历整个文本串。 或者说，更进一步的，如果我们都不能提前知道需要进行匹配的模版，需要我们对于一些动态的模版进行匹配，为了满足速度的要求，我们只能通过预处理$T$串，引入了后缀数组的概念。 算法介绍问题建模我们先来看$KMP$算法，$KMP$的重点和精华在于它的“失配函数”，是一种“用自己匹配自己”的思想。 根据$P$的结构，来进行失配函数的构造。我们可以大概的猜测到这个思想：如果一段字符串不能满足匹配的条件，那么即使我进行右移的操作，根据$P$的性质不同，即有可能还是无法满足匹配条件的。 失配函数的核心就在于找出：一旦出现了不匹配的情况，我们至少需要进行多少次的右移才有可能找到一个匹配情况。 如果寻找到了失配函数，那么剩下的问题也就可以迎刃而解。 对于后缀数组来说，问题要复杂的多，因为我们做不到对于模版的预处理，只能去处理文本串$T$。 根据刘汝佳书上的例子，对于一个给定的字符串，比如$BANANA$，我们可以在它的最后添加一个$\\$$，某个从来没有出现的符号，使得后缀一定可以和一颗$Trie$的叶节点一一对应。注意这里的$\\$$比所有的字符都小。 我们现在的任务就是将一个字符串的所有后缀按字典序进行一个排列。后缀就是从对应位置$i$开始到这个数组结束的全部字符组成的字符串。 大体的思想是首先对于字符串进行一次排序，如图： 之后每次都对于一个二元组进行排序，这里的每一个二元组都可以看作是后缀前两个字符的名次。如图： 之后依次类推，对后缀的前$2^k$的元素进行排序等等。 不过，分析可知，如果使用快速排序，这个算法的复杂度是$O(n\\lg ^2n)$，仍然是比较高的。 所以这里我们使用了基数排序的方法，每次的复杂度为$O(n)$，最后的总的复杂度是$O(n\\lg n)$。 求解方法在前面我们已经详细讲解了算法的思想，具体实现上，不论是$KMP$还是后缀数组，都比较固定，基本没有太多的变化，可以套模版完成。 对于$KMP$算法，首先需要计算失配函数： 1234567891011void getFail (char *P, int *f) &#123; int m = strlen(P); f[0] = 0; f[1] = 0; for (int i = 1; i &lt; m; ++i) &#123; int j = f[i]; while (j &amp;&amp; P[i] != P[j]) j = f[j]; f[i + 1] = P[i] == P[j] ? j + 1 : 0; &#125;&#125; 之后可以利用失配函数，计算最后的结果： 12345678910void find (char *T, char *P, int *f) &#123; int n = strlen(T), m = strlen(P); getFail (P, f); int j = 0; for (int i = 0; i &lt; n; ++i) &#123; while (j &amp;&amp; P[j] != T[j]) j = f[j]; if (P[j] == T[j]) ++j; if (j == m) print(i - m + 1); // 找到匹配 &#125;&#125; 对于后缀数组，其计算比较简单，但是使用起来比较灵活，这里给出一个比较标准的模版： 12345678910111213141516171819202122232425262728293031323334int wa[MAXN], wb[MAXN], wv[MAXN], ww[MAXN];int sa[MAXN];char str[MAXN];inline bool cmp(int *r, int a, int b, int len) &#123; return r[a] == r[b] &amp;&amp; r[a + len] == r[b + len]; &#125;void da(char *str, int n, int m) &#123; int i, j, p, *x = wa, *y = wb, *t; for(i = 0; i &lt; m; ++i) ww[i] = 0; for(i = 0; i &lt; n; ++i) ww[x[i] = str[i]]++; for(i = 1; i &lt; m; ++i) ww[i] += ww[i-1]; for(i = n - 1; i &gt;= 0; --i) sa[--ww[x[i]]] = i; for(j = p = 1; p &lt; n; j &lt;&lt;= 1, m = p) &#123; for(p = 0, i = n - j; i &lt; n; ++i) y[p++]=i; for(i = 0; i &lt; n; ++i) if(sa[i] &gt;= j) y[p++] = sa[i] - j; for(i = 0; i &lt; m; ++i) ww[i] = 0; for(i = 0; i &lt; n; ++i) ww[wv[i] = x[y[i]]]++; for(i = 1; i &lt; m; ++i) ww[i] += ww[i-1]; for(i = n-1; i &gt;= 0; --i) sa[--ww[wv[i]]] = y[i]; for(t = x, x = y, y = t, x[sa[0]] = 0, p = i = 1; i &lt; n; ++i) x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++; &#125;&#125; 解题报告Poj 2406 Power Strings问题描述Given two strings a and b we define ab to be their concatenation. For example, if a = “abc” and b = “def” then ab = “abcdef”. If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = “” (the empty string) and a^(n+1) = a*(a^n). Input Each test case is a line of input representing s, a string of printable characters. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case. Output For each s you should print the largest n such that s = a^n for some string a. 算法设计这道题目需要求出：如果字符串是某一个字串自我重复的结果，找出这个子串，如果有多个子串，选择最短的那一个。 显然，任何一个字符串都是它自己本身重复一次的结果。这里就需要使用自己本身去匹配自己，不难联想到$KMP$算法里面的失配函数，显然，如果满足右移以后可以匹配自己，那么这里一定存在子串并且满足：经过多次的重复以后，可以拼凑成原串。 所以，通过计算失配函数，其最后一项一定是满足性质的子串长。如果这个长度可以整除原串长，那么最后的结果就是题目所求的重复次数。 程序代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000000 + 5;char str[MAXN];int next[MAXN];void getNext(size_t length) &#123; int k = -1, j = 0; ::next[0] = -1; while (j &lt; length) &#123; if (k == -1 || str[k] == str[j]) &#123; ++k; ++j; ::next[j] = k; &#125; else &#123; k = ::next[k]; &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%s\", str) &amp;&amp; str[0] != '.') &#123; size_t length = strlen(str); getNext(length + 1); if (!(length % (length - ::next[length]))) &#123; printf(\"%lu\\n\", length / (length - ::next[length])); &#125; else &#123; printf(\"1\\n\"); &#125; &#125;&#125; 性能分析对于$KMP$算法的建表过程，是一个$O(n)$的算法，所以整个算法的复杂度其实就是$O(n)$。 编程技术技巧这道题目在编程上没有太多的技巧可言，唯一需要注意的是：如何从求重复的子串联想到使用$KMP$算法的失配函数。对于算法还是需要灵活的理解。 Poj 3693 Maximum repetition substring问题描述The repetition number of a string is defined as the maximum number R such that the string can be partitioned into R same consecutive substrings. For example, the repetition number of “ababab” is 3 and “ababa” is 1. Given a string containing lowercase letters, you are to find a substring of it with maximum repetition number. Input The input consists of multiple test cases. Each test case contains exactly one line, whichgives a non-empty string consisting of lowercase letters. The length of the string will not be greater than 100,000. The last test case is followed by a line containing a ‘#’. Output For each test case, print a line containing the test case number( beginning with 1) followed by the substring of maximum repetition number. If there are multiple substrings of maximum repetition number, print the lexicographically smallest one. 算法设计这道题目是综合难度特别大的一题，设计的概念比较多，其中的$RMQ$算法，将会在下一章提及，这里先不做过多的说明。 首先，如果仅仅只求出了$sa$数组，其实是不够用的。通常情况下，我们需要定义两个辅助的数组：$rank$和$height$，其中，$rank_i$表示后缀$i$在$sa$数组中的下标。$heighti$表示定义为$sa{i - 1}$和$sa_i$的最长公共前缀$(LCP)$的长度。 如果两个字符串的$LCP$长度为$k$，意味着这两个字符串的前$k$个字符都相同，但是第$k +1$个字符不同。 对于两个后缀$j$和$k$，不妨设$rank_j &lt; rank_i$，则可以证明后缀$i$和$k$的$LCP$长度为$height[rank_j+1], height[rank_j+2], \\dots, height[rank_k]$中的最小值。即为$RMQ(height, rank_j+1, rank_k)$。 使用以上的方法进行构造以后，可以求解答案。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 100000 + 5;int wa[MAXN], wb[MAXN], wv[MAXN], ww[MAXN];int Rank[MAXN], sa[MAXN], lcp[MAXN], dp[MAXN][20], tmpRes[MAXN];char str[MAXN];inline bool cmp(int *r, int a, int b, int len) &#123; return r[a] == r[b] &amp;&amp; r[a + len] == r[b + len]; &#125;void da(char *str, int n, int m) &#123; int i, j, p, *x = wa, *y = wb, *t; for(i = 0; i &lt; m; ++i) ww[i] = 0; for(i = 0; i &lt; n; ++i) ww[x[i] = str[i]]++; for(i = 1; i &lt; m; ++i) ww[i] += ww[i-1]; for(i = n - 1; i &gt;= 0; --i) sa[--ww[x[i]]] = i; for(j = p = 1; p &lt; n; j &lt;&lt;= 1, m = p) &#123; for(p = 0, i = n - j; i &lt; n; ++i) y[p++]=i; for(i = 0; i &lt; n; ++i) if(sa[i] &gt;= j) y[p++] = sa[i] - j; for(i = 0; i &lt; m; ++i) ww[i] = 0; for(i = 0; i &lt; n; ++i) ww[wv[i] = x[y[i]]]++; for(i = 1; i &lt; m; ++i) ww[i] += ww[i-1]; for(i = n-1; i &gt;= 0; --i) sa[--ww[wv[i]]] = y[i]; for(t = x, x = y, y = t, x[sa[0]] = 0, p = i = 1; i &lt; n; ++i) x[sa[i]] = cmp(y, sa[i-1], sa[i], j) ? p-1 : p++; &#125;&#125;void getLcp(char *str, int n) &#123; for (int i = 0; i &lt;= n; ++i) &#123; Rank[sa[i]] = i; &#125; int h = 0; lcp[0] = 0; for (int i = 0; i &lt; n; ++i) &#123; int j = sa[Rank[i] - 1]; h ? h-- : 0; for (; j + h &lt; n &amp;&amp; i + h &lt; n; ++h) &#123; if (str[i + h] != str[j + h]) break; &#125; lcp[Rank[i] - 1] = h; &#125;&#125;void RMQ_init(int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = lcp[i - 1]; &#125; for (int i = 1; (1 &lt;&lt; i) &lt;= n; ++i) &#123; for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j) &#123; dp[j][i] = min(dp[j][i - 1], dp[j + (1 &lt;&lt; (i - 1))][i - 1]); &#125; &#125;&#125;int RMQ(int left, int right) &#123; left = Rank[left]; right = Rank[right]; if (left &gt; right) swap(left, right); ++left; int k = 0; while ((1 &lt;&lt; (k + 1)) &lt;= right - left + 1) ++k; return min(dp[left][k], dp[right - (1 &lt;&lt; k) + 1][k]);&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif int count = 0; while (scanf(\"%s\", str) &amp;&amp; str[0] != '#') &#123; int length = (int)strlen(str); da(str, length + 1, 'z' + 1); getLcp(str, length); RMQ_init(length); int maxMatch = -1; int cnt = 0; for (int len = 1; len &lt;= length; ++len) &#123; int match; for (int i = 0; i + len &lt; length; i += len) &#123; match = RMQ(i, i + len); int pos = i - (len - match % len); match = match / len + 1; if (pos &gt;= 0 &amp;&amp; RMQ(pos, pos + len) &gt;= len) ++match; if (maxMatch &lt; match) &#123; maxMatch = match; cnt = 0; tmpRes[cnt++] = len; &#125; else if (maxMatch == match &amp;&amp; len != tmpRes[cnt - 1]) tmpRes[cnt++] = len; &#125; &#125; bool flag = false; for (int i = 1; i &lt;= length &amp;&amp; !flag; ++i) &#123; for (int j = 0; j &lt; cnt &amp;&amp; !flag; ++j) &#123; if (RMQ(sa[i], sa[i] + tmpRes[j]) &gt;= tmpRes[j] * (maxMatch - 1)) &#123; str[sa[i] + tmpRes[j] * maxMatch] = '\\0'; flag = true; printf(\"Case %d: %s\\n\", ++count, str + sa[i]); &#125; &#125; &#125; &#125;&#125; 性能分析对于后缀数组而言，需要的构造时间是$O(n\\lg n)$。而$RMQ$可以做到$O(n\\lg n)$的建立时间，和$O(1)$的查询时间。所以总的时间为$O(n\\lg n)$。 编程技术技巧此题难度在于多种解题技巧的混合应用，单单就编程方面来说，技巧不是特别的多。 不过在最后进行输出的时候，可以直接利用printf的性质，将索引到的字符串尾部添加\\0可以直接输出。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"树状数组","date":"2018-01-26T10:02:55.881Z","path":"2018/01/26/Binary Indexed Tree/","text":"Binary Indexed Tree问题描述首先来引入一个问题： 给定$n$个数字，有两种频繁的操作需要处理： 求$\\sum_{k = i}^j A_k$； 对某个$A_i$数据进行增减操作。 如果我们使用普通的数组，这两种操作的复杂度分别为$O(n)$和$O(1)$，如果进行$m$次操作，最坏的情况下，复杂度是$O(mn)$的。 所以，为了降低复杂度，我们可以使用一种数组数组的结构，可以将复杂度降低到$O(m\\lg n)$。当然，可以使用$RMQ$的方法，但是$RMQ$的编程实现稍微麻烦些，所以这里介绍数组数组的方法。 算法介绍问题建模因为每个整数都能表示为一些2的幂次方的和，类似于海明码的思路，我们可以使用一个数组，每个数组保存一段数字的求和结果。即为数组里面的元素$BIT_i$对于某一段数据“负责”。 那么如何指定划分的方法，使得每个数组元素各司其职，不会导致浪费呢？我们可以通过对应下标转换为二进制以后的数字来进行确定。这里我们根据每个元素最右边的$1$的位置$r$进行判断。指定索引$i$的负责区域是从$i - 2^r + 1$到$i$。如图所示： 那么如何确定最右边$1$的位置？我们借助计算机基础的知识可知：$r = x \\&amp; (-x)$。 值得一提的是，树状数组中，我们使得下标从$1$开始，这样可以极大的方便我们编程处理。 那么此时获取从数据开头到结尾的求和就很简单，只要给定了数组的下标，我们就可以了解到是哪些$BIT$里面的数据在储存这些求和，将其相加就好。 同样的修改也是类似的思路，我们只需要知道如果知道了需要修改位置的下标，就可以确定需要修改哪些“负责人”的值。 求解方法对于求$r$，在C++里可以将其定义为内联函数，方便求解： 123inline int lowbit(int x) &#123; return x &amp; (-x);&#125; 如果需要求解从开始到位置$i$这一段的和，通过迭代的方式，可以很方便的找到负责任的节点，进行累加操作： 12345678int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125; 如果需要更新某一个位置的数据，可以做一个求和的逆运算，从低往上的修改负责位置： 123456void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125; 在题目的求解过程中，我们经常使用一个求区间$[i, j]$的和的操作，很容易想到，可以通过求$sum(i)$和$sum(j)$以后，直接相减获得。 但是注意到，这里其实是出现了很多的浪费，主要表现为区间$[1, min(i, j)]$中，有相当一部分数据辛辛苦苦求出来以后，又再次相减掉了。其中最坏的情况是只求一个数字，如求$A_i$，这样有$2\\times (\\ulcorner\\log_2i\\urcorner + 1)$次求解都被浪费，对于这种情况，是有对应的方法的。但是会增加些代码复杂性，而且在$O()$标记中是系数项，没有本质影响，在此我们可以先忽视它。 解题报告Poj 3321 Apple Tree问题描述There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree. The tree has N forks which are connected by branches. Kaka numbers the forks by 1 to N and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree. The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka? Input The first line contains an integer N (N ≤ 100,000) , which is the number of the forks in the tree.The following N - 1 lines each contain two integers u and v, which means fork u and fork v are connected by a branch.The next line contains an integer M (M ≤ 100,000).The following M lines each contain a message which is either“C x“ which means the existence of the apple on fork x has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.or“Q x“ which means an inquiry for the number of apples in the sub-tree above the fork x, including the apple (if exists) on the fork xNote the tree is full of apples at the beginning Output For every inquiry, output the correspond answer per line. 算法设计题目中需要求解的是一个子树上所有苹果的个数，如果我们直接开辟空间维护每个子树，那么不论是空间还是时间都是不可以接受的。考虑到树状数组能够求和的性质，我们记录每个点到根节点的上共有多少的苹果。 但是仅仅维护这个数据是不够的，因为我们并不知道从一个树杈上长出来的苹果总和。所以，需要使用$DFS$对于每个节点进行一个编号，同时，对于每一个分叉节点，记录自己从最小孩子到最大孩子的编号，方便查找。这样我们通过查询一个树杈最大最小儿子分别到根节点的苹果数，将这两者相减就是自己所有孩子的苹果总数。最后再加上自己的苹果，就是需要查询的内容。 注意到，题目只保证了根节点编号为$1$，所以需要自己维护一个映射关系，方便从题目给定的节点映射到按照$DFS$顺序访问的节点。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 100000 + 10;int BIT[MAXN];struct Edge &#123; int to; int next;&#125;;struct Map &#123; int begin; int end;&#125;;Edge edge[MAXN * 2];int head[MAXN];Map idMap[MAXN];int apple[MAXN];int cnt;int id;inline void addEdge(int u, int v) &#123; edge[++cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt;&#125;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;void DFS(int u, int father) &#123; idMap[u].begin = ++id; for (int i = head[u]; i != 0; i = edge[i].next) &#123; if (edge[i].to == father) continue; DFS(edge[i].to, u); &#125; idMap[u].end = id;&#125;int n, i, u, v, m;char c;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;n); for (i = 0; i &lt; n - 1; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; DFS(1, -1); for (i = 1; i &lt;= n; ++i) &#123; apple[i] = 1; &#125; for (i = 1; i &lt;= n; ++i) &#123; edit(idMap[i].begin, 1); &#125; scanf(\"%d\", &amp;m); while (m--) &#123; getchar(); scanf(\"%c %d\", &amp;c, &amp;u); if (c == 'C') &#123; if (apple[u]) &#123; apple[u] = 0; edit(idMap[u].begin, -1); &#125; else &#123; apple[u] = 1; edit(idMap[u].begin, 1); &#125; &#125; else &#123; printf(\"%d\\n\", apple[u] + sum(idMap[u].end) - sum(idMap[u].begin)); &#125; &#125;&#125; 性能分析由之前的分析可以知道，每次对于$BIT$的操作复杂度都是$O(\\lg n)$，所以，一共是$m$次输入，总共的复杂度为$O(m\\lg n)$，对于这个树来说，之前$DFS$的$O(n)$的遍历可以不计。 编程技术技巧存粹编程的角度来说，此题并没有使用太多的技巧。 不过第一次接触，很难想到求一个子树和的问题，可以转为一个线性数组的求和。相当于通过$DFS$遍历标号以后，将一个二维的结构，转为一个一维的结构进行求解。通过迂回的求出每个点到根的苹果总数，相减后求子树苹果总和的方法十分巧妙。 Poj 1990 MooFest问题描述Every year, Farmer John’s N (1 &lt;= N &lt;= 20,000) cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. Each cow i has an associated “hearing” threshold v(i) (in the range 1..20,000). If a cow moos to cow i, she must use a volume of at least v(i) times the distance between the two cows in order to be heard by cow i. If two cows i and j wish to converse, they must speak at a volume level equal to the distance between them times max(v(i),v(j)). Suppose each of the N cows is standing in a straight line (each cow at some unique x coordinate in the range 1..20,000), and every pair of cows is carrying on a conversation using the smallest possible volume. Compute the sum of all the volumes produced by all N(N-1)/2 pairs of mooing cows. Input Line 1: A single integer, N Lines 2..N+1: Two integers: the volume threshold and x coordinate for a cow. Line 2 represents the first cow; line 3 represents the second cow; and so on. No two cows will stand at the same location. Output Line 1: A single line with a single integer that is the sum of all the volumes of the conversing cows. 算法设计这里的树状数组应用比较巧妙，并不是很好想，因为需要输出最小的音量和，我们将牛先按照听力从大到小的顺序排列，优先满足听力差的牛。 这时，需要维护两个树状数组，一个用来求解这头牛$i$坐标之前的牛数，一个用来计算当前的距离和。 这样可以将当前的牛分成两组，一边是坐标在左边的，一边是坐标在右边的。通过距离和听力来求出音量。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int MAXN = 20000 + 5;struct Cow &#123; int v; int x;&#125;;bool cmp(const Cow &amp;lhs, const Cow &amp;rhs) &#123; return lhs.v &lt; rhs.v;&#125;Cow cow[MAXN];ull BITCount[MAXN];ull BITDistance[MAXN];int n;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline ull sum(int x, ull *BIT) &#123; ull res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, ull *BIT, ull delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d\", &amp;cow[i].v, &amp;cow[i].x); &#125; sort(cow, cow + n, cmp); ull res = 0; ull totalDistance = 0; for (int i = 0; i &lt; n; ++i) &#123; ull leftCount = sum(cow[i].x, BITCount); ull leftDistance = sum(cow[i].x, BITDistance); res += (ull)cow[i].v * (leftCount * (ull)cow[i].x - leftDistance); res += (ull)cow[i].v * (totalDistance - leftDistance - ((ull)i - leftCount) * (ull)cow[i].x); totalDistance += (ull)cow[i].x; edit(cow[i].x, BITCount, 1); edit(cow[i].x, BITDistance, (ull)cow[i].x); &#125; printf(\"%llu\\n\", res);&#125; 性能分析这里对于排序和两个树状数组的操作，复杂度都是$O(n\\lg n)$，所以最后的复杂度不变。 编程技术技巧此题其实不容易想到构造两个树状数组进行求解，因为树状数组的性质只对于求和比较方便，所以这里需要一次求和区分坐标，一次求和区分距离。 Poj 2892 Tunnel Warfare问题描述During the War of Resistance Against Japan, tunnel warfare was carried out extensively in the vast areas of north China Plain. Generally speaking, villages connected by tunnels lay in a line. Except the two at the ends, every village was directly connected with two neighboring ones. Frequently the invaders launched attack on some of the villages and destroyed the parts of tunnels in them. The Eighth Route Army commanders requested the latest connection state of the tunnels and villages. If some villages are severely isolated, restoration of connection must be done immediately! Input The first line of the input contains two positive integers n and m (n, m ≤ 50,000) indicating the number of villages and events. Each of the next m lines describes an event. There are three different events described in different format shown below: D x: The x-th village was destroyed.Q x: The Army commands requested the number of villages that x-th village was directly or indirectly connected with including itself.R: The village destroyed last was rebuilt. Output Output the answer to each of the Army commanders’ request in order on a separate line. 算法设计此题思路比较清晰，因为地道在不断的被破坏，所以需要用一个动态的数组进行维护求和。这里使用了树状数组进行求和。但是我们需要查找从某个点$i$处，左右的连续地道，所以此时需要对数组进行全局的搜索，找到一个满足要求的最长连续区间。 值得一提的是，如果直接暴力搜索，每一次查询的复杂度都是$O(n\\lg n)$，最后的复杂度是$O(n^2\\lg n)$，比较耗时。这里我们可以使用二分查找的思想，寻找到满足要求的区间值。 最后，这道题目需要进行修复的工作，我们可以通过一个简单的栈结构进行记录。 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 50000 + 5;int BIT[MAXN];int stack[MAXN];int tmp[MAXN];int sp;int n, m, x;char input;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt;= n) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;int countLeft(int x) &#123; int left = 0, right = x; int mid; int pos = 0; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (sum(x) - sum(mid) == 0) &#123; pos = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return pos;&#125;int countRight(int x) &#123; int left = x - 1, right = n; int mid; int pos = 0; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (sum(mid) - sum(x - 1) &gt; 0) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; pos = mid; &#125; &#125; return pos;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;m); while (m--) &#123; getchar(); scanf(\"%c\", &amp;input); if (input != 'R') scanf(\"%d\", &amp;x); switch (input) &#123; case 'D': tmp[x] = 1; stack[sp++] = x; edit(x, 1); break; case 'Q': if (tmp[x] == 1) &#123; printf(\"0\\n\"); continue; &#125; else &#123; printf(\"%d\\n\", countRight(x) - countLeft(x)); &#125; break; default: int pos = stack[--sp]; tmp[pos] = 0; edit(pos, -1); break; &#125; &#125;&#125; 性能分析因为这里使用了二分查找进行优化，所以每一次查询工作都是$O(\\lg^2n)$的复杂度。最后总的复杂度是$O(n\\lg^2n)$。 编程技术技巧这道题目是使用二分进行优化的一个很巧妙的例子，通过使用二分查找，将$O(n)$次操作降低到了$O(\\lg n)$。这就体现了二分的思想是无所不在的。每当我们需要一个搜索操作的时候，都可以考虑能够进行二分的改善。 Poj 2481 Cows问题描述Farmer John’s cows have discovered that the clover growing along the ridge of the hill (which we can think of as a one-dimensional number line) in his field is particularly good. Farmer John has N cows (we number the cows from 1 to N). Each of Farmer John’s N cows has a range of clover that she particularly likes (these ranges might overlap). The ranges are defined by a closed interval [S,E]. But some cows are strong and some are weak. Given two cows: cowi and cowj, their favourite clover range is [Si, Ei] and [Sj, Ej]. If Si &lt;= Sj and Ej &lt;= Ei and Ei - Si &gt; Ej - Sj, we say that cowiis stronger than cowj. For each cow, how many cows are stronger than her? Farmer John needs your help! Input The input contains multiple test cases.For each test case, the first line is an integer N (1 &lt;= N &lt;= 10^5), which is the number of cows. Then come N lines, the i-th of which contains two integers: S and E(0 &lt;= S &lt; E &lt;= 10^5) specifying the start end location respectively of a range preferred by some cow. Locations are given as distance from the start of the ridge. The end of the input contains a single 0. Output For each test case, output one line containing n space-separated integers, the i-th of which specifying the number of cows that are stronger than cowi. 算法设计题目比较基础，唯一需要进行改进的地方在于，需要对于输入的区间进行排序操作。 因为要统计活动范围能够覆盖其他牛的强壮牛的个数，所以将牛的活动区间按照左端点进行从小到大的排序，如果遇到了左端点相同的情况，需要对于右端点进行从大到小的排序。 这样，在对于排好序的区间进行遍历的时候，只要计算范围内的点的总数就好。 不过，如果有重合的情况，我们还需要通过保存一个过程手动进行处理。 最后，只需要将之前的数据正向的恢复，按照输入的顺序再次排序，即可完成。 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int BIT[MAXN];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += BIT[x]; x -= lowbit(x); &#125; return res;&#125;inline void edit(int x, int delta) &#123; while (x &lt; MAXN) &#123; BIT[x] += delta; x += lowbit(x); &#125;&#125;struct CowRange &#123; int x; int y; int index; int res; CowRange(): x(0), y(0), index(0), res(0) &#123;&#125; CowRange(int x, int y, int index): x(x), y(y), index(index), res(0) &#123;&#125;&#125;;bool preHandle(const CowRange&amp; lhs, const CowRange&amp; rhs) &#123; return lhs.x &lt; rhs.x || ((lhs.x == rhs.x) &amp;&amp; (lhs.y &gt; rhs.y));&#125;bool finishHandle(const CowRange&amp; lhs, const CowRange&amp; rhs) &#123; return lhs.index &lt; rhs.index;&#125;CowRange cows[MAXN];int n;int cnt;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n) &#123; int x, y; memset(BIT, 0, sizeof(BIT)); cnt = 0; while (cnt &lt; n) &#123; scanf(\"%d %d\", &amp;x, &amp;y); CowRange &amp;r = cows[cnt++]; r.x = x; r.y = y; r.index = cnt; &#125; int pointCnt = 0, saveCnt = 0; sort(cows, cows + cnt, preHandle); for (int i = 0; i &lt; cnt; ++i) &#123; if (i != 0 &amp;&amp; cows[i].y == cows[i - 1].y &amp;&amp; cows[i].x == cows[i - 1].x)&#123; cows[i].res = saveCnt; &#125; else &#123; int aeCnt = pointCnt - sum(cows[i].y + 1); cows[i].res = aeCnt; saveCnt = aeCnt; &#125; ++pointCnt; edit(cows[i].y + 2, 1); &#125; sort(cows, cows + cnt, finishHandle); for (int i = 0; i &lt; cnt - 1; ++i) &#123; printf(\"%d \", cows[i].res); &#125; printf(\"%d\\n\", cows[cnt - 1].res); &#125;&#125; 性能分析这里对于树状数组和排序操作的复杂度相同，全都为$O(n\\lg n)$。 编程技术技巧因为题目和前面$3$题都很像，思想也基本类似，所以技巧可以参考前面的题目。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"并查集","date":"2018-01-26T06:47:03.191Z","path":"2018/01/26/UnionFind/","text":"UnionFind问题描述在计算机科学中，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作： $Find$：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 $Union$：将两个子集合并成同一个集合。 由于支持这两种操作，一个不相交集也常被称为联合-查找数据结构（union-find data structure）或合并-查找集合（merge-find set）。其他的重要方法，MakeSet，用于建立单元素集合。有了这些方法，许多经典的划分问题可以被解决。为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为代表，以表示整个集合。接着，$Find(x)$返回 x 所属集合的代表，而$Union$使用两个集合的代表作为参数。 更进一步的，当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系。 带权并查集即是结点存有权值信息的并查集。 算法介绍问题建模并查集的本质是一个森林，每棵树代表一个集合，树根为集合的代表元。 我们可以使用有根树来进行建模，对于一个新加入的节点，就将其添加到对应的集合里面去。那么如何维护这个集合关系呢？只需要使得每个节点保存自己父亲节点即可。 但是即便如此，效率也还是不高，因为随着规模的增大，树的深度提高，查找的效率下降严重。所以，每次查找的时候，如果路径较长，则修改信息，以便下次查找的时候速度更快。这就是“路径压缩”的思想。 同时，我们也可以维护一个$rank$值，表示一个树的规模，我们总是把小树合并到大树上面，这样可以有效的降低深度，防止最坏情况的发生。 求解方法并查集的代码书写十分简单，首先初始情况下，可以把每个点都看成是一个小的集合，通过将$father$数组指定为自己本身来实现。 在$Find$操作中，如果祖宗节点就是自己本身，则可以直接返回；如果不是自己，需要进行递归的操作，具体来说，在计算权值关系的同时，需要将自己合并到自己的祖宗节点之上，通过这个方式可以有效的降低树的深度。 在$Union$操作中，通过比较$rank$来进行合并的操作，可以有效的减少复杂度。 C++代码如下： 123456789101112131415161718192021222324void init () &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125;&#125;int setFind(int x) &#123; if (father[x] == x) return x; int tmpFather = father[x]; father[x] = setFind(father[x]); relation[x] = caculateRelation; return father[x];&#125;void setUnion(int r, int x, int y, int rx, int ry) &#123; int rx = setFind(x); int ry = setFind(y); if (rank[rx] &gt; rank[ry]) &#123; father[ry] = rx; relation[ry] = caculateRelation; &#125; else &#123; father[rx] = ry; relation[rx] = caculateRelation; &#125;&#125; 值得一提的是，使用并查集操作，其复杂度为$O(\\alpha(n))$，其中$\\alpha()$为阿克曼函数的反函数。 解题报告Poj 1182 食物链问题描述动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input 第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output 只有一个整数，表示假话的数目。 算法设计食物链题目是带权并查集的经典题目，首先我们需要明确这里的关系是什么。 根据题目的含义，我们总结出下面三种关系： 关系 代表 和父亲节点同类 0 被自己的父亲节点吃 1 吃自己的父亲节点 2 首先判断数据的规模是否符合题目范围的限制，这个很容易判断。 之后，通过$Find$函数判断这两个点是否在同一个关系集合下面，如果是同一个集合，这里分为两种情况： 是同类 可以直接判断，如果存在“吃”的关系，则说谎数目增加， 否则，将关系纳入并查集中。 存在“吃”或者“被吃”的关系 注意到，这里的食物链其实是一种循环的关系，如图所示： 所以，可以通过取模的关系，进行判断，具体为：$(R_x + d) \\% 3\\ ==\\ R_y$。 如果两者之间没有关系，则需要对关系进行合并，注意合并的时候，一定要分清需要将谁合并到谁，因为这里除了信息给出的新关系，还需要考虑两个节点和各自的祖宗之间的关系，比较复杂。这里给出一个例子：$((3 - R_x) + R_y + d - 1) \\ \\% \\ 3$。 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Relation &#123; int father; int relation; Relation(): father(0), relation(0) &#123;&#125;&#125;;const int MAXN = 50000 + 5;Relation unionFind[MAXN];int n, k;int setfind(int x) &#123; if (unionFind[x].father == x) return x; int tmpFather = unionFind[x].father; unionFind[x].father = setfind(unionFind[x].father); unionFind[x].relation = (unionFind[tmpFather].relation + unionFind[x].relation) % 3; return unionFind[x].father;&#125;void unionSet(int d, int x, int y, int fx, int fy) &#123; unionFind[fx].father = fy; unionFind[fx].relation = ((3 - unionFind[x].relation) + unionFind[y].relation + d - 1) % 3;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; unionFind[i].father = i; &#125; int res = 0; int d, x, y; while (k--) &#123; scanf(\"%d %d %d\", &amp;d, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; ++res; continue; &#125; if (d == 2 &amp;&amp; x == y) &#123; ++res; continue; &#125; int fx = setfind(x); int fy = setfind(y); if (fx == fy) &#123; if (d == 1 &amp;&amp; unionFind[x].relation != unionFind[y].relation) &#123; ++res; continue; &#125; else if (d == 2 &amp;&amp; (unionFind[y].relation + 1) % 3 != unionFind[x].relation) &#123; ++res; continue; &#125; &#125; else &#123; unionSet(d, x, y, fx, fy); &#125; &#125; printf(\"%d\\n\", res);&#125; 性能分析由于并查集操作十分的快捷，可以认为其中的每次添加或者查询的时间复杂度是$O(\\alpha(n))$级别的，所以最后总的时间复杂度是$O(n\\alpha(n))$。 编程技术技巧此时是并查集的模版题，其中的大部分代码可以直接复用。 不过，虽然并查集本身的操作复杂度很低，我们仍然可以对$Union$操作进行些许的优化。因为这里就题目而言，我们一定会在$Union$操作之前进行两次的$Find$操作，所以这里可以直接将上一步中得到的$x$和$y$的祖先节点，传入$Union$函数中，就不用在$Union$函数中反复的调用了。 Poj 1733 Parity game问题描述Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on. Your task is to guess the entire sequence of numbers. You suspect some of your friend’s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer. Input The first line of input contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either ‘’even’’ or ‘’odd’’ (the answer, i.e. the parity of the number of ones in the chosen subsequence, where ‘’even’’ means an even number of ones and ‘’odd’’ means an odd number). Output There is only one line in output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked. 算法设计这道题目虽然是使用并查集完成，但是内部的关系不是很容易理清。因为输入的区间是包括了端点，所以很容易出现了区间重合的情况不好区分，于是可以将左端点减一以后，看作是一个左开右闭区间，这样书写起来关系就可以比较清晰。 稍有计算机常识的都可以知道，对于一段数据的奇偶性进行运算可以使用异或 (^)的方法。我们可以通过此运算，对于中间关系进行求解。 但是，这道题还有一点很重要的技巧，因为输入的区间过于庞大，所以如果直接使用给定的范围开辟空间，十分容易卡空间。所以需要进行一个$hash$化的处理。$hash$的方法很多，比较简单的是使用C++的$STL$里面的$map$，进行处理。因为$map$内部使用了红黑树，有良好的平衡性，所以开销不是很高，编程极容易实现。 程序代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;struct Relation &#123; int father; int relation; Relation(): father(0), relation(0) &#123;&#125;&#125;;const int MAXN = 10000 + 3;const int MAXSIZE = 5000 + 3;Relation set[MAXN];unsigned x_array[MAXSIZE];unsigned y_array[MAXSIZE];int r_array[MAXSIZE];int p = 0;map&lt;unsigned, int&gt; hashMap;int setFind(int x) &#123; if (set[x].father == x) return x; int tmpFather = set[x].father; set[x].father = setFind(set[x].father); set[x].relation = set[x].relation ^ set[tmpFather].relation; return set[x].father;&#125;void setUnion (int r, int x, int y, int rx, int ry) &#123; if (rx &lt; ry) &#123; set[ry].father = rx; set[ry].relation = r ^ set[x].relation ^ set[y].relation; &#125; else &#123; set[rx].father = ry; set[rx].relation = r ^ set[x].relation ^ set[y].relation; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif int n, size; scanf(\"%d\", &amp;n); scanf(\"%d\", &amp;size); unsigned t_x, t_y; int x, y, r; char str[5]; for (int i = 0; i &lt; MAXN; ++i) &#123; set[i].father = i; &#125; int res = 0; for (int i = 0; i &lt; size; ++i) &#123; scanf(\"%u %u %s\", &amp;t_x, &amp;t_y, str); hashMap[t_x] = 0; hashMap[t_y] = 0; if (str[0] == 'e') r_array[i] = 0; else r_array[i] = 1; x_array[i] = t_x; y_array[i] = t_y; &#125; for (map&lt;unsigned, int&gt;::iterator i = hashMap.begin(); i != hashMap.end(); ++i) &#123; i-&gt;second = ++p; &#125; for (int i = 0; i &lt; size; ++i) &#123; x = hashMap[x_array[i]]; y = hashMap[y_array[i]]; r = r_array[i]; --x; int rx = setFind(x); int ry = setFind(y); if (rx != ry) &#123; setUnion(r, x, y, rx, ry); ++res; &#125; else &#123; if (set[x].relation ^ set[y].relation ^ r) break; ++res; &#125; &#125; printf(\"%d\\n\", res);&#125; 性能分析对于每一步的关系处理来说，都是$O(1)$的操作，所以仍然为最后的$O(\\alpha(n))$级别。不过在$hash$的过程中，每一步是$O(\\lg n)$的级别。所以最后的时间复杂度是由$hash$主导，为$O(n\\lg n)$。在Poj平台上为235MS。 编程技术技巧这道题目主要有三个特别注意的地方： 使用左开右闭区间代替原来的题目描述，方便编程和自己的理解。 使用异或操作降低复杂度，如果采用和第一题一样的取模的方法，从计算机系统的角度考虑耗时要高。 使用$STL$里的$map$来进行$hash$化的操作，开销较小，并且编程容易实现。 Poj 2912 Rochambeau问题描述N children are playing Rochambeau (scissors-rock-cloth) game with you. One of them is the judge. The rest children are divided into three groups (it is possible that some group is empty). You don’t know who is the judge, or how the children are grouped. Then the children start playing Rochambeau game for M rounds. Each round two children are arbitrarily selected to play Rochambeau for one once, and you will be told the outcome while not knowing which gesture the children presented. It is known that the children in the same group would present the same gesture (hence, two children in the same group always get draw when playing) and different groups for different gestures. The judge would present gesture randomly each time, hence no one knows what gesture the judge would present. Can you guess who is the judge after after the game ends? If you can, after how many rounds can you find out the judge at the earliest? Input Input contains multiple test cases. Each test case starts with two integers N and M (1 ≤ N ≤ 500, 0 ≤ M ≤ 2,000) in one line, which are the number of children and the number of rounds. Following are M lines, each line contains two integers in [0, N) separated by one symbol. The two integers are the IDs of the two children selected to play Rochambeau for this round. The symbol may be “=”, “&gt;” or “&lt;”, referring to a draw, that first child wins and that second child wins respectively. Output There is only one line for each test case. If the judge can be found, print the ID of the judge, and the least number of rounds after which the judge can be uniquely determined. If the judge can not be found, or the outcomes of the M rounds of game are inconsistent, print the corresponding message. 算法设计本题的思路和食物链基本一致，甚至解题主体都是差不多的。唯一的区别是引入了一个裁判，这个裁判不属于任何的集合，每次都可以说不同的话。所以为了找出谁是裁判，需要对于每个人进行一次假设，判断如果他是裁判，能不能没有冲突。所以这里需要循环$n$次。如果没有一个是满足的，则输出”Impossible”，如果有很多裁判都可以导致没有冲突，则输出”Can not determine”。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int MAXM = 2000 + 5;const int MAXN = 500 + 5;int father[MAXN];int relation[MAXN];int x_array[MAXM];int y_array[MAXM];int r_array[MAXM];int n, m;int x, y, r;int setFind(int x) &#123; if (father[x] == x) return x; int tmpFather = father[x]; father[x] = setFind(father[x]); relation[x] = (relation[x] + relation[tmpFather]) % 3; return father[x];&#125;void setUnion(int r, int x, int y, int rx, int ry) &#123; // int rx = setFind(x); // int ry = setFind(y); father[ry] = rx; relation[ry] = (relation[x] + (3 - relation[y]) + r) % 3;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d\", &amp;n, &amp;m) == 2) &#123; memset(x_array, 0, sizeof(x_array)); memset(y_array, 0, sizeof(y_array)); memset(r_array, 0, sizeof(r_array)); char rTmp; for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d%c%d\", x_array + i, &amp;rTmp, y_array + i); if (rTmp == '&lt;') r_array[i] = 1; else if (rTmp == '&gt;') &#123; r_array[i] = 2; &#125; else r_array[i] = 0; &#125; int judgeCnt = 0; int judge = 0; int line = -1; for (int current = 0; current &lt; n; ++current) &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125; memset(relation, 0, sizeof(relation)); bool flag = true; for (int i = 0; i &lt; m; ++i) &#123; x = x_array[i]; y = y_array[i]; r = r_array[i]; if (x == current || y == current) continue; int rx = setFind(x); int ry = setFind(y); if (rx == ry) &#123; if ((relation[y] + (3 - relation[x])) % 3 != r) &#123; // cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; line = max(line, i); flag = false; break; &#125; &#125; else &#123; setUnion(r, x, y, rx, ry); &#125; &#125; if (flag) &#123; judge = current; ++judgeCnt; &#125; &#125; if (!judgeCnt) &#123; printf(\"Impossible\\n\"); &#125; else if (judgeCnt == 1) &#123; printf(\"Player %d can be determined to be the judge after %d lines\\n\", judge, line + 1); &#125; else &#123; printf(\"Can not determine\\n\"); &#125; &#125;&#125; 性能分析因为内部需要对裁判的可能性进行判断，所以进行$n$次的遍历。总的复杂度为$O(n^2\\alpha(n))$。 编程技术技巧思路和食物链基本一致，可以参考前面的编程技巧。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"差分约束系统","date":"2018-01-24T09:51:03.626Z","path":"2018/01/24/System of Difference Constraints/","text":"System of Difference Constraints问题描述首先先引入一个通用的线性规划问题，给定一个$m \\times n$的矩阵A，一个$m$维的向量$b$和一个$n$维向量$c$。希望能够找到一个$n$维的向量$x$，使得在由$Ax \\leqslant b$给定的$m$个约束条件下优化目标函数$\\sum_{i = 1}^n c_ix_i$，使得目标函数的取值最大。有时，我们并不关心目标函数，而是仅仅希望能找到一个可行解，即找到任何满足$Ax \\leqslant b$的向量$x$，或者判断不存在可行解。 观察一个特例情况，如果线性规划的矩阵$A$的每一行包括一个1和一个-1，其他的所有项皆为0。则对于$Ax \\leqslant b$所给出的约束条件变为$m$个涉及$n$个变量的差额限制条件，此时每个约束条件退化为简单的线性不等式：$x_j - x_i \\leqslant b_k$。这里$1 \\leqslant i, j \\leqslant n$，$i \\neq j$，且$1 \\leqslant k \\leqslant m$。 算法介绍问题建模对于此类问题，可以从图论的角度进行理解。 在一个$Ax \\leqslant b$的差分约束系统中，我们将$m \\times n$的线性规划矩阵$A$看作是一张由$n$个节点和$m$条边构成的图的邻接矩阵的转置。这里定义下约束图的概念： 约束图是一个带有权重的有向图$G = (V, E)$，这里 $V = {v_0, v_1, …, v_n }$，$E = {(v_i, v_j): x_j - x_i \\leqslant b_k } \\bigcup {(v_0, v_1), (v_0, v_2, …, (v_0, v_n)}$。 这里的$v_0$可以看作是一个额外的节点，用来保证图中至少有一个节点，并且从其出发可以到达所有的其他的节点。其中，如果$x_j - x_i \\leqslant b_k$是一个差分约束条件，则边$(v_i, v_j)$的权重为$w(v_i, v_j) = b_k$。 举例说明： 对于一组差分约束条件：$$\\begin{cases}x_1 - x_2 \\leqslant 0\\x_1 - x_5 \\leqslant -1\\x_2 - x_5 \\leqslant 1\\x_3 - x_1 \\leqslant 5\\x_4 - x_1 \\leqslant 4\\x_4 - x_3 \\leqslant -1\\x_5 - x_3 \\leqslant -3\\x_5 - x_4 \\leqslant -3\\\\end{cases}$$可以描绘出如下的差分约束系统的约束图： 其中，$(-5, -3, 0, -1, -4)$为满足条件的一个解。 不难发现，使用最短路算法中的松弛操作：$d(v) - d(u) \\leqslant w(u, v)$，刚好可以转为一个差分约束的条件：$i - j \\leqslant u$。于是，对于差分约束的问题，可以将未知数$x_i$对应一个顶点，将不等式$x_i - x_j \\leqslant c$转化为一条从$x_j$到$x_i$权值为$c$的边。 下面考虑两种特殊情况： 无解。当图中出现了负权环的时候，此时的最短路可以无限小，表现为$x_i - x_j \\leqslant c$中的$c$可以无限的小，所以满足条件的最大值不存在。 有无穷多解。当图中出现了不连通的情况，即起点$s$到终点$t$不可达，此时表示没有约束条件，即有无穷多的解。 求解方法对于一个最短路问题，经常使用$Dijkstra$算法或$Bellman-Ford$算法进行求解。如果转化的图中没有负权值的边，可以使用复杂度更低的$Dijkstra$算法进行计算。如果存在负权值的情况，当然可以通过$Bellman-Ford$算法进行判断，但是此算法的复杂度是$O(mn)$，我们这里使用改进版的$SPFA$算法进行求解。 123456789101112131415161718192021bool spfa(s) for i from 0 to n - 1 d[i] = (i == s) ? 0 : INF; inq[i] = (i == s); // 入队列标记 visitCount[i] = 0; // 对负权环进行判断 q.push( (d[s], s) ); while( !q.empty() ) (dist, u) = q.pop(); // 取首元素 inq[u] = false; if( visitCount[u]++ &gt; n ) // 存在负权环 return true; for u 出发的所有的边 e v = edge[e].v; w = edge[e].w; if(d[u] + w &lt; d[v]) d[v] = d[u] + w; // 松弛操作 if ( !inq[v] ) inq[v] = true; q.push( (d[v], v) ); return false; 解题报告Poj 3159 Candies问题描述During the kindergarten days, flymouse was the monitor of his class. Occasionally the head-teacher brought the kids of flymouse’s class a large bag of candies and had flymouse distribute them. All the kids loved candies very much and often compared the numbers of candies they got with others. A kid A could had the idea that though it might be the case that another kid B was better than him in some aspect and therefore had a reason for deserving more candies than he did, he should never get a certain number of candies fewer than B did no matter how many candies he actually got, otherwise he would feel dissatisfied and go to the head-teacher to complain about flymouse’s biased distribution. snoopy shared class with flymouse at that time. flymouse always compared the number of his candies with that of snoopy’s. He wanted to make the difference between the numbers as large as possible while keeping every kid satisfied. Now he had just got another bag of candies from the head-teacher, what was the largest difference he could make out of it? Input The input contains a single test cases. The test cases starts with a line with two integers N and M not exceeding 30 000 and 150 000 respectively. N is the number of kids in the class and the kids were numbered 1 through N. snoopy and flymouse were always numbered 1 and N. Then follow M lines each holding three integers A, B and c in order, meaning that kid A believed that kid Bshould never get over c candies more than he did. Ouput Output one line with only the largest difference desired. The difference is guaranteed to be finite. 算法设计可以看出，每一个孩子在心里对于“公平”都有不同的界定，可以用一个不等式来描述他们每个人能够容忍的最大的差异性对待。 比如$1\\ 2\\ 5$表述了孩子$1$能够容忍孩子$2$比自己多$5$块糖果。那么可以表达为：$x_2 - x_1 \\leqslant 5$，对应到图上是一个从点$x_1$到点$x_2$的一个权值为$5$的边。 分析可知，这里的所有权值都为正数，可以直接使用$Dijkstra$进行编写。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 30000 + 10;const int MAXM = 150000 + 10;const int INF = 0x3f3f3f3f;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;struct Pair &#123; int v; int w; Pair(int _v, int _w): v(_v), w(_w) &#123;&#125;&#125;;struct Cmp &#123; bool operator() (const Pair&amp; lhs, const Pair&amp; rhs) &#123; return lhs.w &gt; rhs.w; &#125;&#125;;int n, m;int u, v, w;int d[MAXN];bool visited[MAXN];void dijkstra(int s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; visited[i] = false; &#125; priority_queue&lt;Pair, vector&lt;Pair&gt;, Cmp&gt;q; q.push(Pair(s, 0)); visited[s] = true; d[s] = 0; while (!q.empty()) &#123; Pair current = q.top(); if (current.v == n) return; q.pop(); visited[current.v] = true; for (int i = head[current.v]; i != 0; i = edge[i].next) &#123; if (visited[edge[i].to]) continue; if (d[current.v] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current.v] + edge[i].w; q.push(Pair(edge[i].to, d[edge[i].to])); &#125; &#125; &#125;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; dijkstra(1); printf(\"%d\\n\", d[n]);&#125; 性能分析此处使用了优先队列优化的$Dijkstra$算法，算法的复杂度为$O(E\\lg V)$，空间上使用了链式向前星，减少了建图$malloc$的开销，最后Poj上的开销为：空间 2432K，时间672MS。 编程技术技巧 在建图的过程中，如果使用临接矩阵的结构，则空间开销为$O(n^2)$。如果使用临接表结构，此时很难估计规模，需要产生$malloc$的开销。这里使用了链式向前星，预先根据输入的规模开辟数组，通过链表的形式，将边储存下来，进行同时保证了访问的快捷性。 $Dijkstra$算法可以通过判断是否已经在$V$集合中进行剪枝的操作，避免不必要的运算。经对比发现，速度增加了$100\\%$。 Poj 1275 Cashier Employment问题描述A supermarket in Tehran is open 24 hours a day every day and needs a number of cashiers to fit its need. The supermarket manager has hired you to help him, solve his problem. The problem is that the supermarket needs different number of cashiers at different times of each day (for example, a few cashiers after midnight, and many in the afternoon) to provide good service to its customers, and he wants to hire the least number of cashiers for this job. The manager has provided you with the least number of cashiers needed for every one-hour slot of the day. This data is given as R(0), R(1), …, R(23): R(0) represents the least number of cashiers needed from midnight to 1:00 A.M., R(1) shows this number for duration of 1:00 A.M. to 2:00 A.M., and so on. Note that these numbers are the same every day. There are N qualified applicants for this job. Each applicant i works non-stop once each 24 hours in a shift of exactly 8 hours starting from a specified hour, say ti (0 &lt;= ti &lt;= 23), exactly from the start of the hour mentioned. That is, if the ith applicant is hired, he/she will work starting from ti o’clock sharp for 8 hours. Cashiers do not replace one another and work exactly as scheduled, and there are enough cash registers and counters for those who are hired. You are to write a program to read the R(i) ‘s for i=0..23 and ti ‘s for i=1..N that are all, non-negative integer numbers and compute the least number of cashiers needed to be employed to meet the mentioned constraints. Note that there can be more cashiers than the least number needed for a specific slot. Input The first line of input is the number of test cases for this problem (at most 20). Each test case starts with 24 integer numbers representing the R(0), R(1), …, R(23) in one line (R(i) can be at most 1000). Then there is N, number of applicants in another line (0 &lt;= N &lt;= 1000), after which come N lines each containing one ti (0 &lt;= ti &lt;= 23). There are no blank lines between test cases. Output For each test case, the output should be written in one line, which is the least number of cashiers needed.If there is no solution for the test case, you should write No Solution for that case. 算法设计此题转化为图的分析过程比较复杂，首先已知量是$R_0, R1,\\dots, R{23}$表示从$0$开始到$23$点结束每个小时需要的员工数量，同时$B_0, B1, \\dots, B{23}$是从这一刻能够开始工作的人的数量，这个数据可以从应聘者这里获得。现在需要解决的问题是，如何求出每个时刻需要开始工作的人数。 如果我们使用$A_0, A1, \\dots, A{23}$表示在对应的时刻能够开始工作的人数，因为每个人一天可以工作$8$个小时，所以要考虑到工人跨天的情况，对于$i \\geqslant 7$的情况：$$A{i-7} + A{i -6} + A_{i - 5} + \\dots + A_i \\geqslant R_i$$对于$0 \\leqslant i &lt; 7$的情况：$$(A_0 + \\dots + Ai)+ (A{i + 17} + \\dots + A_{23}) \\geqslant R_i$$但是，仅仅这个约束条件是不够的，对于$i \\in [0, 24)$，我们还有：$$0 \\leqslant A_i \\leqslant B_i$$为了方便起见，可以使用$Si = \\sum{j = 0}^{i}A_j$来表示一段的和。 则上面的式子可以转化为：$$\\begin{cases}Si - S{i - 8} \\geqslant R_i &amp; i \\geqslant 7\\Si + S{23} - S_{i + 16} \\geqslant R_i &amp; 0 \\leqslant i &lt; 7\\0 \\leqslant Si - S{i - 1} \\leqslant Bi &amp; 0 \\leqslant i &lt; 24\\\\end{cases}$$就可以直接将这个式子转化为图进行计算，但是这里注意到，$S{23}$是一个未知量，所以这里需要进行枚举$S_{23}$的可能取值，选择一个能够满足条件最小的进行输出。 注意这里有点技巧，$S_{23}$虽然值不大，但是也是$O(n)$级别，和求职者的个数相关，所以可以采用二分查找的方法，将复杂度降低到$O(\\lg n)$。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 1000 + 10;const int MAXM = 2000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN; &#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;bool inQueue[MAXN];int d[MAXN];int visitedCnt[MAXN];int qTime;int m;int u, v, w;bool spfa(int s) &#123; for (int i = 1; i &lt;= 24; ++i) &#123; d[i] = INF; inQueue[i] = false; &#125; d[s] = 0; visitedCnt[s] = 1; inQueue[s] = true; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; if (visitedCnt[edge[i].to]++ &gt; 24) return false; inQueue[edge[i].to] = true; push(edge[i].to); &#125; &#125; &#125; &#125; return true;&#125;int R[25];int b[25];int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif scanf(\"%d\", &amp;qTime); while (qTime--) &#123; memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= 24; ++i) &#123; scanf(\"%d\", R + i); &#125; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(\"%d\", &amp;u); ++b[u + 1]; &#125; int res = 0; int l = 1, r = m; int middle; while (l &lt;= r) &#123; middle = (l + r) &gt;&gt; 1; memset(head, 0, sizeof(head)); cnt = h = t = 0; memset(visitedCnt, 0, sizeof(visitedCnt)); for (int i = 8; i &lt;= 24; ++i) &#123; addEdge(i, i - 8, -R[i]); &#125; for (int i = 1; i &lt;= 7; ++i) &#123; addEdge(i, i + 16, -R[i] + middle); &#125; for (int i = 1; i &lt;= 24; ++i) &#123; addEdge(i, i - 1, 0); addEdge(i - 1, i, b[i]); &#125; addEdge(24, 0, -middle); addEdge(0, 24, middle); if (spfa(0)) &#123; res = middle; r = middle - 1; &#125; else &#123; l = middle + 1; &#125; &#125; if (res) printf(\"%d\\n\", res); else printf(\"No Solution\\n\"); &#125;&#125; 性能分析由于$SPFA$的算法复杂度由论文可知为$O(kE)$，建图需要$O(n)$，而对于二分查找需要$O(\\lg n)$次，所以最后的复杂度是$O(n\\lg n)$。最后Poj上开销为空间188K，时间16MS。 编程技术技巧分配收银员这题，第一次使用了$SPFA$算法，在何时对于不可能的情况（即出现了负权的环）进行剪枝是十分重要的，我们可以在将点入队列前，进行检查，这样可以节省一定的开销。 同时正如前面讲过的，如果出现了一个有序的排列，并且我们需要对其进行搜索，那么此时使用二分法进行查找是十分高效的，必须要将二分法熟练的掌握。 Poj 1201 Intervals问题描述You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.Write a program that:reads the number of intervals, their end points and integers c1, …, cn from the standard input,computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,writes the answer to the standard output. Input The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) – the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1. Output The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n. 算法设计题目中给定的条件为每个区间内至少需要选中的点的个数，现在求整个区间需要被选中的点的个数$S$，并且使得$S$最小。 此题的思路可以参考上面的一题，因为最后需要求出一个完整区间的个数，所以直接设$S_i$为$[0, i)$中点的个数。于是，举个例子，如果题目输入$1\\ 3\\ 1$，则可以转化为：$S_3 - S_1 \\geqslant 1$。 当然，值得一提的是，仅仅这些条件是不够的，我们必须要保证每个点最多只能被选中一次。所以有：$1 \\geqslant Si - S{i - 1} \\geqslant 0$。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 60000 + 10;const int MAXM = 240000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN;&#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;bool inQueue[MAXN];int d[MAXN];int n;int u, v, w;int left, right;bool spfa(int s) &#123; for (int i = ::left; i &lt;= ::right; ++i) &#123; d[i] = INF; inQueue[i] = false; &#125; d[s] = 0; inQueue[s] = true; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; inQueue[edge[i].to] = true; push(edge[i].to); &#125; &#125; &#125; &#125; return true;&#125;int main (int argc, char * argv[]) &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d\", &amp;n) == 1) &#123; memset(head, 0, sizeof(head)); cnt = h = t = 0; ::left = MAXN; ::right = 0; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(v + 1, u, -w); ::left = min(::left, u); ::right = max(::right, v + 1); &#125; for (int i = ::left; i &lt;= ::right; ++i) &#123; addEdge(i, i - 1, 0); addEdge(i - 1, i, 1); &#125; spfa(::right); printf(\"%d\\n\", d[::right] - d[::left]); &#125;&#125; 性能分析对于每一次的运算，基本可以看作是$SPFA$的时间开销，即$O(kE)$。在Poj上的运行时间是313MS。 编程技术技巧这里的区间范围是$[1, 5000]$，可以接受，但是如果输入的数字本身的范围比较小的话，我们可以只考虑题目中出现的范围，这样将图缩小很多，提高运行的速度。 具体来说，输入的时候需要记录本样例的最左边和最右边的值，计算时只需要计算这两个值即可。 ###Poj 3169 Layout 问题描述Like everyone else, cows like to stand close to their friends when queuing for feed. FJ has N (2 &lt;= N &lt;= 1,000) cows numbered 1..N standing along a straight line waiting for feed. The cows are standing in the same order as they are numbered, and since they can be rather pushy, it is possible that two or more cows can line up at exactly the same location (that is, if we think of each cow as being located at some coordinate on a number line, then it is possible for two or more cows to share the same coordinate). Some cows like each other and want to be within a certain distance of each other in line. Some really dislike each other and want to be separated by at least a certain distance. A list of ML (1 &lt;= ML &lt;= 10,000) constraints describes which cows like each other and the maximum distance by which they may be separated; a subsequent list of MD constraints (1 &lt;= MD &lt;= 10,000) tells which cows dislike each other and the minimum distance by which they must be separated. Your job is to compute, if possible, the maximum possible distance between cow 1 and cow N that satisfies the distance constraints. Input Line 1: Three space-separated integers: N, ML, and MD. Lines 2..ML+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at most D (1 &lt;= D &lt;= 1,000,000) apart. Lines ML+2..ML+MD+1: Each line contains three space-separated positive integers: A, B, and D, with 1 &lt;= A &lt; B &lt;= N. Cows A and B must be at least D (1 &lt;= D &lt;= 1,000,000) apart. Output Line 1: A single integer. If no line-up is possible, output -1. If cows 1 and N can be arbitrarily far apart, output -2. Otherwise output the greatest possible distance between cows 1 and N. 算法设计做完前面的$3$题以后，这道题目就比较简单了。 输入有两种，分别是两头牛最多距离多远和两头牛最少相隔多远。这个条件可以很容易的转化为不等式来书写。 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;const int MAXM = 20000 + 10;const int INF = 0x3f3f3f3f;int q[MAXN];int h, t;inline void push(int i) &#123; q[t++] = i; if (t == MAXN) t -= MAXN;&#125;inline int pop() &#123; int tmp = q[h++]; if (h == MAXN) h -= MAXN; return tmp;&#125;inline bool empty() &#123; return h == t;&#125;struct Edge &#123; int to; int w; int next;&#125;;Edge edge[MAXM];int head[MAXN];int cnt;inline void addEdge(int u, int v, int w) &#123; edge[++cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;int inQueue[MAXN];int d[MAXN];int n;int u, v, w;int ml, md;int visitCnt[MAXN];bool spfa(int s) &#123; for (int i = 1; i &lt;= n; ++i) &#123; d[i] = INF; &#125; d[s] = 0; inQueue[s] = true; visitCnt[s] = 1; push(s); while (!empty()) &#123; int current = pop(); inQueue[current] = false; for (int i = head[current]; i != 0; i = edge[i].next) &#123; if (d[current] + edge[i].w &lt; d[edge[i].to]) &#123; d[edge[i].to] = d[current] + edge[i].w; if (!inQueue[edge[i].to]) &#123; inQueue[edge[i].to] = true; push(edge[i].to); if (++visitCnt[edge[i].to] &gt; n) return false; &#125; &#125; &#125; &#125; return true;&#125;int main () &#123; std::ios::sync_with_stdio(false);#ifdef LOCAL freopen(\"input.txt\", \"r\", stdin);#endif while (scanf(\"%d %d %d\", &amp;n, &amp;ml, &amp;md) == 3) &#123; memset(head, 0, sizeof(head)); memset(visitCnt, 0, sizeof(visitCnt)); cnt = h = t = 0; for (int i = 0; i &lt; ml; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; for (int i = 0; i &lt; md; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addEdge(v, u, -w); &#125; if (spfa(1)) &#123; if (d[n] != INF) printf(\"%d\\n\", d[n]); else printf(\"-2\\n\"); &#125; else printf(\"-1\\n\"); &#125;&#125; 性能分析同上题一样，使用$SPFA$算法，复杂度类似。 编程技术技巧本题就是差分约束系统的基础题型，思想和前面的$3$题类似，没有特别的技巧。","tags":[{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"ASPLOS半日行","date":"2017-04-17T13:09:05.000Z","path":"2017/04/17/ASPLOS/","text":"ASPLOS半日行真是出乎意料，自己能以本科生的身份 体验了计算机顶级会议ASPLOS 2017 作为一个还在刷 CSAPP 的小白，十分幸运能够来到西安，和众多世界级的科学家坐在一起，聆听并感受CS最前沿的科技革新。在此，首先要感谢的是为我们争取机会的@石老师，以及同行的15级ACM班全体大佬们。 长安古风 一日看尽长安花 标志的大雁塔，东西两部的钟楼和鼓楼 厚重的西安城墙，依稀看到古都的影子 biangbiang面，羊肉泡馍，特色的西安小吃 粗犷的西北饮食风格，感受长安城独到的魅力 Main Conference开场第一次接触这种顶级的会议，没有想象中的严肃刻板。反而感受到了一种轻松融洽的气氛，周围就坐的人都非常友善亲切。 阿里的首席科学家周靖人开场讲解了阿里云的技术创新，不仅包括大数据和AI，还有各种交互式 流计算和图计算等等。在数据质量检测和机器学习方面，也有所涉及。 虽然关于技术讲解并没有想象中的高深莫测，但也足够窥见阿里背后的惊人的技术投入，我对于阿里的印象也从策划公司转变到了科技公司，感受到了企业对于世界计算机技术发展的强大推动力。 Lighting Session受制于现在的专业知识水平，如果说之前周靖人的演讲能够让我大体听懂，之后90秒一篇的paper对于我的确有些勉强。能够理解表达的中心含义实属不易，但是即便如此，还是能够感受到这些世界顶级的科研人员对于技术的热情。 像下面这位天生的演讲家。 初步接触到了世界最前沿的技术和发展方向，明白了现在计算机领域究竟在研究什么样的问题，以及问题背后的驱动力量。 Solution并不重要，motivation才是重中之重。 Best Paper很庆幸，在会议之前我们集体研究过上午很多paper的主题，基本上能够更随着主讲者的思路向前推进。个人当然对于会议提到Mallacc和RedSpy比较感兴趣，会议后也关注了RedSpy的开源项目。 虽然对于内部的实现方式仅仅一知半解，但是他们所解决的大问题，也都是我在学习过程中曾经有过的一些小想法。所以，灵感就在转瞬间，如何抓住，如何踏踏实实的研究下去，也是我以后要思考和为之奋斗的问题。 Lunch Time实话实说，这次我的注意力完全没有放在午餐上面。除了保持坐姿和吃相以外，所有的精力都放在了如何同周围的学术大牛交流上面。 坐在对面的是一位芝加哥大学的留学博士生，无奈我口语硬伤，使用纯英文沟通还是有很多词不达意的情况，最后干脆中英混杂聊了起来。虽然因为语言问题略显尴尬，但还是了解到了相当多的关于留学深造以及国外科研的情况，他也很坦然的教给了我一些关于国外学校和微软亚洲研究院的申请技巧。 当然我们还聊到了本科生的课程问题，他也说出了他的理解，认为没有必要追求最主流的技术，毕竟搞教学最前沿的不一定是最能够让人理解和接受，不然何不每天讲解两篇paper呢。当然，在午饭最后，我也得到了他的邮箱，希望以后能够继续交流。 当然，唯一遗憾的还是没能和斜对面的Best Paper的得主交流。确实，在如何套磁方面我还是一点不懂，口语也并不过关，失去了一些机会，这也是我之后努力的方向吧。 Summary西安的顶会之行真的收获了很多，虽然真正参会的只有半天，但是我也初次窥得了世界最前沿的技术究竟是什么样子；初次了解了计算机究竟应该去做什么，计算机的本质问题是什么；更重要的是能和一批最顶尖的研究者做在一起，去了解他们的研究方式和思维方式。越厉害的人越是谦虚，当一个真正的大牛能够face to face和你交流知识，这种欣喜可想而知。 ASPLOS之行给我心里种下了一颗种子 我已经迫不及待的看到他的生根 发芽 结果 希望这一天，并不遥远。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]},{"title":"2016 Summary","date":"2017-01-22T14:17:00.000Z","path":"2017/01/22/2016 Summary/","text":"2016 Summary一学期竟然过的这么快，真是难以想象。暮然回首时，仿佛还能看见昔日的我。 致往日的我 “ flag 就是用来被推翻的。” 报名时的我依稀记得大一军训的时候，听到了联创这个团队。 “他是联创dalao”，“卧槽，好牛逼啊”。 显然，就像经典的电影桥段，当我终于计划好要报名的时候，发现早就过了截止日期。 一转眼到了大二，在年级群里再一次听到了联创这个名字，仿佛冥冥的召唤，我不假思索的报了名。 显然，就像经典的电影桥段，这一次没有错过。 测试时的我其实我是很期待熬测的，一开始只是觉得好玩。毕竟之前写过一些iOS的App，也是挺想试下自己的能力。 于是，不知哪里来的蜜汁自信，熬测是周五的晚上，我周四的早晨第一次打开了OC基础教程这本书，然后高高兴兴的去赴死。 神奇的是，熬测的OC并没有太难为我，居然收到了最后的面试通知。 最后，还侥幸过了面试。 实习期的我一开始真是没有想到，联创还有如此漫长的实习期。 第一次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 OC基础薄弱，从来没有用纯代码写过项目，各种UI全然不熟悉。直到我看到了一本好书《Copying and pasting from stack overflow》,瞬间打开了新世界的大门。 然后这里贴贴那里补补终于搞定了任务。 第二次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 还记得当时直接理解错了任务，没有用Cell实现，于是，用一天的时间《重构——删除所有代码》，苦于没有美工，自己一点点的贴图，一点点的调整（不得不吐槽，纯代码写UI实在是太狗血了）， 经过了第130次微调，终于有了下面的丑态。 第三次任务时的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 写一个聊天机器人！！我对于网络的知识几乎为0，完全不知道从哪里下手。好在，有了一个月的时间，一个月的时间啊！ “慢慢磨，总是可以磨出来的吧”，我想。 显然，就像经典的电影桥段，我被打脸了。 对于聊天信息的显示，就耗费了我相当多的时间，头像 气泡 对话信息。。。一坨一坨的东西，完全没法驾驭。难以想象，当我实现一个黑白信息条的时候，有多么的兴奋。 “搞定了对话气泡，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我再次被打脸了。 网络的连接，又是一个大坑。POST请求，第一次崩溃，第二次崩溃。。。连Xcode编译器都被我搞了n次崩溃。。。 当控制台终于输出了正确的message时，感觉自己掌握了世界大门的钥匙。 “搞定了网络，之后的应该好写了吧”，我想。 显然，就像经典的电影桥段，我又一次被打脸。 数据库的储存，也是个棘手的问题。当我自己都能背下来存储的数据时，手机就是显示为nil。一次nil，两次nil。。。无尽的空虚。最后才实现了数据的存储功能。 ”搞定了数据，之后的应该好写了吧“，我想。 显然，你知道我要说什么了。 调节UI简直有毒。“一个像素，再移动一个像素吧。”每次都这么说。 最后的最后，呈现了这种效果。 HackDay的我一脸懵逼。 这都是些什么！！！ 苍天，我要GG了。 其实，一开始我并不是特别想参与，感觉寒假有时间能自我充(f\u0001a\u0001ng)实(song)，然后发烧+重感冒，感觉身体被掏空。当我接触到项目的时候，发现我一开始的想法，是对的。PM要求的东西，之前的任务里面根本没有接触过，《iOS开发——从入门到绝望》。 但是，随着一点点的交流沟通，发现组队写一个项目是一件很美好的事情。尤其是有PM和两个Lab组的dalao，自己上传照片的请求被接受，觉得特别有成就感。也感受到了Deadline的刺激，直到最后的一秒钟，才输出了正确的匹配结果。 附上丑图。 致改变的我 “不努力一把，都不知道自己有多菜。” 一个学期，点点滴滴，我终于从一个什么都不懂的小白，变成了一个懂一点东西的小白。 细细想来，自己真的提升了很多。不仅仅是打字的速度，Google的能力，甚至也不仅仅是debug的能力，coding的能力，项目架构的能力。而是对于未知问题的探索能力，每一次的task，都是一次对自己的挑战，“如何利用Deadline提高生产力“，这才是真正的提升。 在和dalao交流的时候，发现了自己特别多的不足。我又想起了马克思主义基本原理的否定之否定规律。每周一次的Meet Up，都是一次对自我的否定，也是我前进发展的动力。从发现自己不会debug，到发现自己不会写代码，之后发现自己不懂计算机，最后怀疑自己是不是只会开机关机。每一次都是绝望再绝望的过程。 致现在的我 “明天的我会不会比今天更强？” 感谢周围的dalao，感谢UniqueStudio这个团队，感谢自己当初的决定和之后的自我否定，感谢自己没有虚度又一个学期。 回忆了过去这么多我，开始对下一年的我，下一月的我，下一周的我，下一刻的我，又有了些期待。 明天的我会不一样吗？ 当然，因为那就是我。","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"},{"name":"联创","slug":"联创","permalink":"http://yoursite.com/tags/联创/"}]},{"title":"小小Q","date":"2017-01-20T00:22:00.000Z","path":"2017/01/20/Wetalk/","text":"小小Q基于Objective-C纯代码的实时聊天应用，使用图灵机器人API接口并支持图片搜索等多种模式的对话沟通。支持本地推送 3D-Touch等等功能。 简介我的第一个成型的APP，开发的第一步。 图片预览","tags":[]},{"title":"Hello World","date":"2017-01-19T13:27:47.000Z","path":"2017/01/19/Hello World/","text":"Hello World Stay Single, Stay Simple 12345#include&lt;stdio.h&gt;int main (int argc, char *argv[])&#123; printf(\"Hello, World!\\n\");&#125; 极客到极致 欢迎访问我的Github","tags":[{"name":"随感","slug":"随感","permalink":"http://yoursite.com/tags/随感/"}]}]